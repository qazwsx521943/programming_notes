{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"My Second Brain","n":0.577},"1":{"v":"\n## Welcome to my learning repository! 📚\n\n**Disclaimer:**\n\nThe content in this repository is a work in progress and should not be considered an authoritative source of information. These notes are currently being compiled during my learning journey at AppWorks School. They are subject to change, and there may be gaps in organization and accuracy.\n\n**Note Status:**\n\nI am actively working on organizing and rectifying any inaccuracies. Expect a more comprehensive set of notes by 2024/01/19.\n\n**Reading guide:**\n\n> Block quotes like this generally means this paragraph is quoted by official documentation.\n\n```swift\n// Example code is typically simplified and may not be practical in real-world scenarios.\n// It is created solely to aid my understanding of the underlying concepts related to a specific topic.\n```\n\nFeel free to connect with me and share your thoughts or suggestions regarding my note-taking process. I appreciate any feedback and collaboration to enhance the quality of these notes.\n\nHappy learning! 🚀","n":0.083}}},{"i":2,"$":{"0":{"v":"Programming","n":1}}},{"i":3,"$":{"0":{"v":"Side Projects","n":0.707}}},{"i":4,"$":{"0":{"v":"Flavor Flash Journal","n":0.577},"1":{"v":"\nFlavor Flash 開發筆記\n\n## Food App\n\n- TA:\n\n  1. 喜歡被動探索美食的人\n  2. 有選擇障礙 / 不想花時間想要吃什麼的人\n  3. 喜歡紀錄食物口感的人\n  4. google評論有時候可以被刷出來、不如朋友圈一起建立可信的美食地圖\n\n- Feature:\n\n  1. 隨機選食物 -> 找附近的餐廳\n  2. 左滑右滑收藏餐廳 (餐廳抽卡,UI要炫砲)\n  3. 美食日記\n     1. 飢餓狀態\n     2. 上傳圖片，\n        1. 後鏡頭拍食物分析食物的標籤(分析不準也可帶入自定義標籤)\n        2. 前鏡頭拍人像分析人臉（喜怒哀樂）作為評價\n     3. 寫下心得\n  4. 可以查看自己曾到訪的餐廳，針對吃的次數給不同顏色圖釘、註解\n  5. 好友的頁面可以查看他的美食日記、以及他的美食地圖(曾到訪的餐廳)\n  6. 聊天系統\n     1. 1對1\n     2. 群組\n     3. 傳jpg、png、gif\n     4. 分享餐廳資訊\n     5. (optional)影片\n     6. (optional)投票要吃的餐廳\n  7. 成就勳章：（月結、週結、小任務）\n     1. 很常吃飯 => 飯桶\n     2. 常常不同的餐廳 => 發現新大陸\n  8. 週飲食習慣、月飲食習慣分析(3D呈現)\n  9. APP顏色要可切換\n  10. 日曆簽到系統，當天有發美食日記的話就算簽到成功\n  11. 動態島、鎖屏提示(Activity Kit)\n\n- 預計需要學的東西:\n  1. MapKit\n     1. Marker & Annotation\n     2. selection\n     3. contentBuilder\n     4. mapStyle\n  2. SpriteKit\n  3. AVFoundation\n  4. CoreML\n     1. Vision\n  5. Firebase APIs\n\n\n- reference:\n  1. https://github.com/PCChuang/Subminder\n  2. https://github.com/TaiHsin/Travel\n  3. https://github.com/pisck888/Hahabbit\n  4. https://github.com/thisisalliet/FocusFoodie\n\n\n![](/assets/images/ifoodie-webconfig.png)\n\n我這次個人專案開發的是一款探索及紀錄美食的app，那會想要開發這款app的原因是因為我每天都會遇到午餐晚餐要吃什麼的問題，再加上女朋友有紀錄以及分享美食的習慣，於是我就決定以這兩個需求去開發這款美食App。\n\n首先，首頁放的是我自己最常使用的功能，那我的使用情境就是在每天中午不知道要吃什麼時候就可以打開來點一下，並且透過調整地圖參數去調整你想看到的餐廳搜尋結果。\n\n那進到地圖搜尋的頁面時，使用者可以透過點擊圖釘以及下方的餐廳卡片去移動到該餐廳的位置，點擊下方卡片也可以看到餐廳的基本資料。\n\n如果我在瀏覽餐廳的時候看到了幾間還不錯的餐廳，我也可以餐廳資訊這邊先加到我的待吃清單，等到下一餐又不知道要吃什麼的時候，也可以從待吃的清單去做選擇。\n\n那如果在地圖上有看到這餐想吃的餐廳時，你就可以點擊該餐廳的圖釘然後點旁邊的地圖icon去開啟apple map的導航。\n\n那回到首頁點擊收藏的ICON就可以看到你待吃名單中的餐廳有哪些，如果吃了就可以把該餐廳移除待吃名單。\n\n那這是探索附近餐廳的功能，接下來要帶過的是記錄美食的功能，使用者可以點擊這個相機的icon開啟前後鏡頭，開啟後使用者可以對鏡頭的顯示做一些調整，查看有沒有死角。\n\n拍好之後也可以再次確認照片沒有問題，做一些簡單的編輯，那如果沒有問題就可以進一步寫下心得。\n\n發文美食評論之後就可在美食足跡的社群中，看到自己跟朋友的發文，你可以對貼文留言&按讚。那如果有一些私底下想詢問的美食問題，也可以去聊天室建立群組聊天。\n\n那除了在這個社群頁面可以看到其他朋友的發文，使用者也可以在個人頁面的foodprint中在地圖上查看他過往吃過的餐廳，也可以跟朋友做足跡的疊加。\n","n":0.097}}},{"i":5,"$":{"0":{"v":"Xcode Issues","n":0.707},"1":{"v":"\n## SPM can't find module\n\n```git\nrm -rf ~/Library/Developer/Xcode/DerivedData\n```\n\n## Fastest Way removing Derived Data\n\n```terminal\nrm -rf ~/Library/Developer/Xcode/DerivedData\n```\n\n## Multiple command produce\n\nhttps://stackoverflow.com/questions/50718018/xcode-10-error-multiple-commands-produce\n\n## Check Thread issue\n\n![](/assets/images/project%20brainstorming.flavor%20flash%20journal.xcode%20issues_check_thread.png)\n\n## XCode project file merge 'group'\n\n要注意合併時，檔案夾之間是否有 source group結尾包住，否則會有啟動不了的問題\n\n```\nE7FFB38B2B1CA2B90065A213 /* FoodPrintHistoryViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FoodPrintHistoryViewModel.swift; sourceTree = \"<group>\"; };\n```\n\n## 如何查看模擬器的UserDefaults plist?\n\nhttps://pradnya-nikam.medium.com/view-and-change-user-defaults-on-ios-simulator-d2c3fc3b82b1\n\n1. 先找到模擬器被存在哪：\n    ```\n    /Users/zhongzhexuan/Library/Developer/CoreSimulator/Devices/BE1B25CF-FBF9-4850-BBCC-58807BA3D19B\n    ```\n2. 進到模擬器的資料夾：\n    ```\n    find . -name ios22-jason.SwiftJunior.plist\n    ```\n3. 如果有UserDefaults檔案，就會搜尋的到\n    ```\n    ./data/Containers/Data/Application/521CEC9B-FB38-4A6B-8329-02CC51188A20/Library/Preferences/ios22-jason.SwiftJunior.plist\n    ```","n":0.128}}},{"i":6,"$":{"0":{"v":"Test","n":1},"1":{"v":"\nIn Xcode, we have to kind of automated test we can write.\n\nXCTest Framework is the framework that helps us write **unit** / **ui** test\n\nTest跟Refactor是相輔相成的，\n如果可以在Refactor之前把Test Code寫好，那你就可以拿來驗證你Refactor後的Code是否也可以正常運作。\n\nXCode中做單元測試的方法：\n\nTesting Class必須繼承XCTestCase，且這個class中的function都必須以test prefix.\n\n最常使用的斷言物件就是`XCTAssertEqual`去測試結果是否符合預期。","n":0.192}}},{"i":7,"$":{"0":{"v":"Unit Test","n":0.707}}},{"i":8,"$":{"0":{"v":"UI Test","n":0.707},"1":{"v":"\n## Goal\n\n確保所有UI物件存在View上","n":0.707}}},{"i":9,"$":{"0":{"v":"Style Guide","n":0.707}}},{"i":10,"$":{"0":{"v":"Custom Styling","n":0.707},"1":{"v":"\n## ButtonStyle, ToggleStyle, etc\n\nThey have a method creates the view.\n\n```swift\nfunc makeBody(configuration: Self.Configuration) -> some View\n```","n":0.258}}},{"i":11,"$":{"0":{"v":"Mapkit","n":1},"1":{"v":"\n## iOS 16.0 (interfacing with UIKit)\n\n當某個struct conform `UIViewRepresentable`\n需要實作 `makeUIView`, `updateUIView` protocol function\n\n### Callback Order\n\n1. makeCoordinator\n   1. Creates the custom instance that you use to communicate changes(by delegates) from your view to other parts of your SwiftUI interface.\n\n    ```swift\n    associatedtype Coordinator = Void\n\n    @MainActor func makeCoordinator() -> Self.Coordinator\n    ```\n\n2. makeUIView\n   1. Creates the view object and configures its initial state.\n\n    ```swift\n    /// You must implement this method and use it to create your view object.\n    /// Configure the view using your app's current data and contents of the\n    /// `context` parameter. The system calls this method only once, when it\n    /// creates your view for the first time. For all subsequent updates, the\n    /// system calls the ``UIViewRepresentable/updateUIView(_:context:)``\n    /// method.\n\n    associatedtype UIViewType : UIView\n\n    func makeUIView(context: Self.Context) -> Self.UIViewType\n    ```\n\n3. updateUIView\n   1. Updates the state of the specified view with new information from SwiftUI.\n   2. When properties like `@Published` changed, calls this method to update portions of your interface affected by those changes.\n\n    ```swift\n    /// When the state of your app changes, SwiftUI updates the portions of your\n    /// interface affected by those changes. SwiftUI calls this method for any\n    /// changes affecting the corresponding UIKit view. Use this method to\n    /// update the configuration of your view to match the new state information\n    /// provided in the `context` parameter.\n    func updateUIView(_ uiView: Self.UIViewType, context: Self.Context)\n    ```\n","n":0.067}}},{"i":12,"$":{"0":{"v":"iOS Version Check","n":0.577},"1":{"v":"\n## `#available(iOS 17, *)`\n\n檢查OS版本來決定要不要運行code\n\n```swift\nif #available(iOS 17, *) {\n    print(\"this code only runs on iOS 17 and up\")\n} else {\n    print(\"this code only runs on iOS 16 and lower\")\n}\n```\n\n## `@available(iOS 17, *)`\n\n定義class/method時標註可被調用的OS版本\n\n```swift\n@available(iOS 17, *)\nfinal class Camera {\n    // ..\n}\n```","n":0.162}}},{"i":13,"$":{"0":{"v":"Firebase","n":1}}},{"i":14,"$":{"0":{"v":"Cloud Messaging","n":0.707}}},{"i":15,"$":{"0":{"v":"Cloud Firestore","n":0.707},"1":{"v":"\n## Keywords\n\n- NoSQL\n- document-oriented database\n\n## What is a document in firestore?\n\nA lightweight record that contains fields, which map to values.\n\n> arrays or nested objects, are called maps\n\n## What is a reference in firestore?\n\nA reference is a lightweight object that just points to a location in your database.\n\n- 拿`collection reference`：\n  - querying the documents in the collection\n\n- 拿`document reference`:\n  - 對該document進行讀寫\n\n拿Reference的小技巧：\n\n```swift\nlet documnetRef = db.document(\"users/jason\")\n```\n\n## Index types in Cloud Firestore\n\n1. single-field indexes\n2. composite indexes\n\n## Data Structuring for cloud firestore\n\n- Always store numbers as doubles\n\n### Options\n\n1. Document：\n2. MultiCollections:\n3. SubCollections within documents:\n\n## Write\n\n### Options\n\n1. 在某個集合中新增檔案，並指定DocumentID\n2. 在某個集合中新增檔案，使用Cloud Firestore自動產生的DocumentID\n3. 在某個集合中新增空檔案（使用Cloud Firestore自動產生的DocumentID），日後在增加資料\n\n### Set document\n\n> 建立 / 覆蓋某個檔案\n\n```swift\n// Update one field, creating the document if it does not exist.\ndb.collection(\"cities\").document(\"BJ\").setData([ \"capital\": true ], merge: true)\n```\n\n如果使用`set()`建立檔案，一定需要給一個DocumentID，但是不是每次我們要建立的資料的ID都需要我們自己產生，這時候可以使用`add()`，這樣就可以請Cloud Firestore幫我們建立這筆資料的DocumentID\n\n> Behind the scenes, .add(...) and .doc().set(...) are completely equivalent, so you can use whichever is more convenient.","n":0.086}}},{"i":16,"$":{"0":{"v":"Apple Sign In","n":0.577}}},{"i":17,"$":{"0":{"v":"WebRTC signalling","n":0.707},"1":{"v":"\n## 如何用Firebase Collection建立一個signalling server?\n\n### 建立一個直播間\n\n1. 建立一個Stream Collection，紀錄存在的直播間\n2. 當使用者按下直播時，我們會透過`WebRTCClient`的`peerConnection`產生一個`RTCSessionDescription`(後續簡稱`sdp`，代表發起直播者提供的`offer`)，他產生的`sdp`我們會將它設為local description。接下來，我們會在Stream Collection建立一個新Document，並將這個`sdp`的資訊存在這個Document中，並給一個`offer`的key。\n\n    ```javascript\n\n    offer: {\n      type: offer.type,\n      sdp: offer.sdp\n    }\n\n    ```\n\n3. 我們開始監聽這個直播間是否有人進入，如果有的話，將這個進來的人的`sdp`設為發起直播者的remote description\n\n### 加入一個直播間\n\n1. 使用者選擇一個想看的直播間，並按下加入，我們會將使用者的remote description設定成開啟直播者的`sdp`，並請`WebRTCClient`的`peerConnection`產生一個`answer`的`sdp`，並將其設為local description。\n\n2. 將產生的answer `sdp`寫入該直播間的document field\n\n    ```javascript\n    answer: {\n      type: answer.type,\n      sdp: answer.sdp\n    }\n    ```\n\n3. 這時候開啟直播的人就會監聽到stream doc的變動，並將加入者的`sdp`設為其remote description，並完成了發起直播與加入直播之間的`sdp`交換\n\n### Collect ICE candidates\n\n","n":0.152}}},{"i":18,"$":{"0":{"v":"Dependency Injection","n":0.707},"1":{"v":"\n## Dependency Injection\n\n> Dependency injection aims to separate the concerns of constructing objects and using them, leading to loosely coupled programs.\n\nCommon used cases:\n\n- When initializing a provider, we might pass in a dataService for the provider to init, and then the provdier can use that dataService instance to fetch Data.\n\n- When using `#Preview` in swiftUI, some views depends on the environment values when rendering the view, so we might use an environment modifier to inject the values that we want to see on the preview canvas.","n":0.108}}},{"i":19,"$":{"0":{"v":"Core Data","n":0.707},"1":{"v":"\n## SwiftUI 中導入Core Data\n\n1. 建立Data Model\n2. 建立DataController / DataManagar Helper class，負責初始化data model persistent store\n3. 在App入口初始化DataController，並透過`@environmnet(\\.managedObjectContext, dataController.container.viewContext)`讓整個view hiearchy 都可以存取到\n\n## 如何使用 `@FetchRequest` property wrapper?\n\n> Always declare properties that have a fetch request wrapper as private.\n","n":0.174}}},{"i":20,"$":{"0":{"v":"Concurrency","n":1},"1":{"v":"\n## Download image\n\n### Old way (escaping closure)\n\nURLSession + escaping completionHandler closure\n\n```swift\nfunc responseHandler(_ data: Data?,_ response: URLResponse?) -> UIImage? {\n    guard\n        let data,\n        let image = UIImage(data: data),\n        let response = response as? HTTPURLResponse,\n        response.statusCode >= 200 && response.statusCode < 300 else {\n          return nil\n        }\n\n        return image\n}\n\n// old school\nfunc downloadWithEscaping(completionHandler: @escaping (_ image: UIImage?, _ error: Error?) -> ()) {\n    URLSession.shared.dataTask(with: URL(string: \"xxx\")) { [weak self] (data, response, error) in\n        let image = responseHandler(data, response)\n        completionHandler(image, error)\n    }\n}\n\n// with combine\nfunc downloadWithCombine() -> AnyPublisher<UIImage?, Error> {\n    URLSession.shared.dataTaskPublisher(for: url)\n        .map(responseHandler)\n        .mapError { $0 }\n        .eraseToAnyPublisher()\n}\n```\n\n### New way (async await)\n\n```swift\nfunc downloadWithAsync() async throws -> UIImage {\n    let (imageData, response) = try await URLSession.shared.data(from: URL(string: \"xxx\")!)\n\n    guard let image = responseHandler(imageData, response) else {\n        throw URLError(.badServerResponse)\n    }\n\n    return image\n}\n```\n\n## How to load multiple images concurrently?\n\n### Problem: loading images in a Task context loads by serial\n\n```swift\nstruct AsyncLetView: View {\n    @State private var images: [UIImage] = []\n\n    @StateObject private var loadImageViewModel = LoadImageViewModel()\n\n    let columns = [GridItem(.flexible()), GridItem(.flexible())]\n\n    var body: some View {\n        LazyVGrid(columns: columns) {\n            ForEach(images, id: \\.self) { image in\n                Image(uiImage: image)\n                .resizable()\n                .scaledToFit()\n                .frame(height: 150)\n            }\n        }\n        .onAppear {\n            Task {\n                let image1 = try await loadImageViewModel.fetchImage()\n                self.images.append(image1)\n                let image2 = try await loadImageViewModel.fetchImage()\n                self.images.append(image2)\n                let image3 = try await loadImageViewModel.fetchImage()\n                self.images.append(image3)\n                let image4 = try await loadImageViewModel.fetchImage()\n                self.images.append(image4)\n            }\n        }\n    }\n}\n```\n\n### Solution 1: Split in different Task\n\n> Cons: bad code\n\n```swift\n   Task {\n    let image1 = try await loadImageViewModel.fetchImage()\n    self.images.append(image1)\n\n   }\n\n   Task {\n    let image2 = try await loadImageViewModel.fetchImage()\n    self.images.append(image2)\n   }\n\n   Task {\n    let image3 = try await loadImageViewModel.fetchImage()\n    self.images.append(image3)\n   }\n\n   Task {\n    let image4 = try await loadImageViewModel.fetchImage()\n    self.images.append(image4)\n   }\n```\n\n### Solution 2: `async let`\n\n> Cons: Better than solution 1, but still not scalable\n\n```swift\nTask {\n    async let fetchImage1 = try await loadImageViewModel.fetchImage()\n    async let fetchImage2 = try await loadImageViewModel.fetchImage()\n    async let fetchImage3 = try await loadImageViewModel.fetchImage()\n    async let fetchImage4 = try await loadImageViewModel.fetchImage()\n\n    let (image1, image2, image3, image4) = try await (fetchImage1, fetchImage2, fetchImage3, fetchImage4)\n\n    images.append(contentsOf: [image1, image2, image3, image4])\n}\n```\n\n### Solution 3: TaskGroup\n\n> Pros: Better than above solution, clean on handling multiple tasks\n> Cons: Need to be careful of the error handling\n\n```swift\nstruct User: Codable {\n    let id: String\n\n    let name: String\n}\n\nfunc fetchUsersWithTaskGroup(ids: [String]) async throws -> [User] {\n    var users: [User] = []\n\n    return try await withThrowingTaskGroup(of: User?.self) { group in\n        for id in ids {\n            group.addTask {\n                try? await fetchUser(userId: id)\n            }\n        }\n\n        for try await user in group {\n            if let user {\n                users.append(user)\n            }\n        }\n\n      return users\n    }\n}\n```\n\n## SDK 不支援 async await （使用completionHandler）\n\n### Solution: 使用`withCheckedThrowingContinuation`包\n\n```swift\nfunc getData(url: URL) async throws -> Data {\n    return try await withCheckedThrowingContinuation { continuation in\n        URLSession.shared.dataTask(with: url) { data, response, error in\n            if let data {\n                continuation.resume(returning: data)\n            } else if let error {\n                continuation.resume(throwing: error)\n            } else {\n                continuation.resume(throwing: URLError(.badURL))\n            }\n        }\n        .resume()\n    }\n}\n```\n\n## 問題： 在還沒有actor之前，要如何解決不同物件之間對同一個class的存取/修改？\n\nA: 在有可能被同時存取的class中宣告特定的Queue，規範某些需要排隊處理的操作。\n\n## What is global Actors?\n\n## What is `@MainActor`?\n\n當某個資料會影響到UI時，會需要標記`@MainActor`，告訴compiler說這個資料需要在main thread做更新才可以確保thread safety。\n\n通常在有標記`@Published`的variable都會需要標記`@MainActor`，或是直接在viewModel標記也可以。\n\n## What is Sendable protocol?\n\n當某個type遵守`Sendable`協議時，並不需要特別定義properties或methods，只是要確保在併發環境下，某個property可以保證thread safe就是符合`Sendable`協議。\n\n> 定義struct時，通常就默認遵守Sendable (value types)\n\n## Manage strong & weak reference with Async / Await?\n\n通常不需要在Task呼叫的closure中做weak self的記憶體管理，而是在Task層面。\n\n如果在ViewModel中做了很多async await的操作，可以將Task的Reference紀錄起來，當View disappear的時候去一一cancel還正在執行的Task。\n\n## MVVM 中使用Async / Await 的 Pattern\n\n相較於在View中使用Task包住ViewModel的function，如果情況允許的話，在ViewModel的function中用Task包住concurrent的code會比較好管理這些Task。","n":0.045}}},{"i":21,"$":{"0":{"v":"Community","n":1},"1":{"v":"\n## QRCode 掃條碼\n\n### 產生QRCode\n\n透過CoreImage的`CIFilter`物件來處理輸入的image data\n\n(CIImage本身不是可以display的view物件，需要先轉成UIImage)\n\n```swift\nimport CoreImage.CIFilterBuiltins\n\nfunc generateQRCode(from string: String) -> UIImage {\n  let context = CIContext()\n  let filter = CIFilter.qrCodeGenerator()\n\n  filter.message = Data(string.utf8)\n\n  if let outputImage = filter.outputImage {\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n      return UIImage(cgImage: cgImage)\n    }\n  }\n\n  return UIImage(systemName: \"xmark.circle\") ?? UIImage()\n}\n```","n":0.146}}},{"i":22,"$":{"0":{"v":"Architecture","n":1},"1":{"v":"\n## Dependency Injection\n\nQ: What did it solve?\n\nA: Singleton design pattern cons\n\n### How it works?\n\n> Use protocols to make a blue print of DataServices\n\n1. Initializing dataServices at a intro level (Can use a Master class to initialize all dataServices)\n2. Passing these dataService instances into Views and use it to initialize view models (Injection)\n\n## Singleton\n\n- Pros:\n\n  1. Very convenient\n  2. Beginner friendly\n\n- Cons:\n\n  1. Singleton's are global (not thread safe)\n  2. can't customize init (bad for testing)\n  3. can't swap out service\n\n## App LifeCycle\n\nPrior to iOS 14, iOS apps had a class named \"AppDelegate\" that the creation of this class was the starting point of an app.\n\n### `@Main` property wrapper\n\nIndicates the entry execution of the app\n\n### 'App' protocol\n\nstruct that conform to the App protocol, has a default implementation of the method `main()`, which manages the launch process of the app.","n":0.085}}},{"i":23,"$":{"0":{"v":"View","n":1},"1":{"v":"\n## Container Views\n\n### VStack -> Vertical\n\n### HStack -> Horizontal\n\n### ZStack -> zIndex (back to front)\n\n> VStack, HStack has default spacing.\n\n## Common Modifiers\n\n### `.frame()`\n\n```swift\nText(\"Hello, World!\")\n  .background(.blue)\n  .frame(width: 300,height: 200, alignment: .bottom)\n  .background(.red)\n```\n\nview before the `.frame()` modifier will be the content of the frame.\n\n### `.background()`是可以不斷疊加上去的\n\n### `.overlay`會在background之上\n\n> background, overlay 設定的alignment是對齊Self的frame.\n\n## `background` vs `ZStack`\n\n當堆疊很多物件時，使用`ZStack`，單純的情況就盡量使用`background`\n\n## 善用`Spacer()`推 Stack 裡面的laout\n\n## How to use `enum` and `init` in swiftUI reusable views\n\n## ScrollView 小技巧\n\n> 可以nest，如果想要做瀑布流可以考慮\n\n```\nScrollView -> VStack -> **ForEach** -> ScrollView -> HStack -> **ForEach** -> RoundedRectangle\n```\n\n如果資料比較多，我們應該要使用LazyVStack, LazyHStack\n\n## Conditional Rendering\n\n1. if else statements ( `||`, `&&` )\n2. ternary operators\n\n\n## Action sheet, Alert view 都是可以封裝成viewBuilder的","n":0.103}}},{"i":24,"$":{"0":{"v":"Reusable View","n":0.707},"1":{"v":"\n## 管理要渲染哪個Loading View的Container View\n\n```swift\npublic struct ActivityIndicatorView: View {\n\n    public enum IndicatorType {\n        case `default`(count: Int = 8)\n        case arcs(count: Int = 3, lineWidth: CGFloat = 2)\n        case rotatingDots(count: Int = 5)\n        case flickeringDots(count: Int = 8)\n        case scalingDots(count: Int = 3, inset: Int = 2)\n        case opacityDots(count: Int = 3, inset: Int = 4)\n        case equalizer(count: Int = 5)\n        case growingArc(Color = .black, lineWidth: CGFloat = 4)\n        case growingCircle\n        case gradient(_ colors: [Color], CGLineCap = .butt, lineWidth: CGFloat = 4)\n    }\n\n    @Binding var isVisible: Bool\n    var type: IndicatorType\n\n    public init(isVisible: Binding<Bool>, type: IndicatorType) {\n        _isVisible = isVisible\n        self.type = type\n    }\n\n    public var body: some View {\n        if isVisible {\n            indicator\n        } else {\n            EmptyView()\n        }\n    }\n\n    // MARK: - Private\n\n    private var indicator: some View {\n        ZStack {\n            switch type {\n            case .default(let count):\n                DefaultIndicatorView(count: count)\n            case .arcs(let count, let lineWidth):\n                ArcsIndicatorView(count: count, lineWidth: lineWidth)\n            case .rotatingDots(let count):\n                RotatingDotsIndicatorView(count: count)\n            case .flickeringDots(let count):\n                FlickeringDotsIndicatorView(count: count)\n            case .scalingDots(let count, let inset):\n                ScalingDotsIndicatorView(count: count, inset: inset)\n            case .opacityDots(let count, let inset):\n                OpacityDotsIndicatorView(count: count, inset: inset)\n            case .equalizer(let count):\n                EqualizerIndicatorView(count: count)\n            case .growingArc(let color, let lineWidth):\n                GrowingArcIndicatorView(color: color, lineWidth: lineWidth)\n            case .growingCircle:\n                GrowingCircleIndicatorView()\n            case .gradient(let colors, let lineCap, let lineWidth):\n                GradientIndicatorView(colors: colors, lineCap: lineCap, lineWidth: lineWidth)\n            }\n        }\n    }\n}\n```\n\n1. 先定義Enum，代表這個Container View可以渲染的Loading View有哪些\n\n2. 定義`init`方式 (傳入一個`isVisible`的Binding variable、一個上面定義好的Loading Type)\n\n3. 透過`computed value`決定這個view要渲染哪個Loading View\n\n## Loading View怎麼設計的\n\n先決定Loading想要的變化(Ex: 透明度、長度、變形)\n\n## How to extract Subviews\n\n1. Simple view => 拆成其他computed value就可以\n2. Need reusability(stateful view) => extract into subview","n":0.065}}},{"i":25,"$":{"0":{"v":"PreferenceKey","n":1},"1":{"v":"\n## `.navigationTitle(_ title: String)` 是怎麼運作的？\n\n通常在child view中要改變parent view的值我們會使用Binding的方式，但是像navigationTitle這種modifier我們並沒有做綁定，為什麼還是可以在任何child view中改變parent view的navigationTitle呢？\n\n當某個View透過modifier設定navigationTitle時，實際上是透過PreferenceKey去改變最父層的navigationTitle\n\n```swift\nstruct CustomPreferenceKey: PreferenceKey {\n  static var defaultValue: String = \"\"\n\n  static func reduce(value: inout String, nextValue: () -> String) {\n    value = nextValue()\n  }\n}\n```\n\n- Steps:\n  1. 建立一個遵從`PreferenceKey`的struct\n  2. Parent View 用`onPreferenceChange`modifier監聽\n  3. Child View用`preference(key: RectGeoPreferenceKey.self, value: size)`改變自定義的struct\n\n## 使用情境\n\n1. 監聽`scrollView`中某個View的offset","n":0.146}}},{"i":26,"$":{"0":{"v":"Grid","n":1},"1":{"v":"\n## `LazyVGrid` Instagram layout\n\n```swift\nstruct LazyVGridView: View {\n    var body: some View {\n    ScrollView {\n    Rectangle()\n      .fill(AngularGradient(colors: [.blue, .purple, .red], center: .bottomLeading))\n      .frame(width: .infinity, height: 500)\n\n    LazyVGrid(\n        columns: [\n            GridItem(.flexible(), spacing: 10),\n            GridItem(.flexible(), spacing: 10),\n            GridItem(.flexible(), spacing: 10),\n        ],\n        alignment: .leading,\n        spacing: 10,\n        pinnedViews: [.sectionHeaders],\n        content: {\n            Section {\n              ForEach(0..<20) { index in\n                  Rectangle()\n                    .frame(height: 150)\n              }\n            } header: {\n              Text(\"This is Section 1\")\n                  .font(.subheadline)\n                  .foregroundStyle(.brown)\n            }\n        })\n    }\n    }\n}\n\n```","n":0.12}}},{"i":27,"$":{"0":{"v":"Divider","n":1},"1":{"v":"\n## ------ Text ------ Effect\n\n```swift\nDivider()\n  .frame(height: 2)\n  .overlay(.gray)\n  .padding()\n  .overlay {\n    Text(\"Continue with Email\")\n      .font(.caption)\n      .padding(.horizontal, 10)\n      .background(.black)\n  }\n```","n":0.229}}},{"i":28,"$":{"0":{"v":"Clean UI Code","n":0.577},"1":{"v":"\n## Clean UI code in swiftUI\n\nYou can organize UI code using the following techniques to maintain cleaner UI code in your project:\n\n1. ViewModifiers\n2. ViewBuilders\n3. extract subviews","n":0.196}}},{"i":29,"$":{"0":{"v":"Shape","n":1},"1":{"v":"\n\n## 畫邊框\n\n```swift\nCircle()\n  .stroke(\n    Color.green,\n    style: StrokeStyle(lineWidth: 10, lineCap: .square, dash: [40])\n  )\n```\n\n![Circle stroke](/assets/images/project%20brainstorming.flavor%20flash%20journal.View.CircleStroker.png)\n\n```swift\nstruct PathView: View {\n    var body: some View {\n  ZStack {\n   Path { path in\n    path.move(to: CGPoint(x: 20, y: 100))\n    path.addLine(to: CGPoint(x: 370, y: 100))\n   }\n   .stroke(style: StrokeStyle(lineWidth: 30, lineCap: .square))\n  }\n    }\n}\n```\n\n![linecap](/assets/images/project%20brainstorming.flavor%20flash%20journal.View.stroke_linecap.png)\n\n```swift\n  GeometryReader { geometry in\n   ZStack {\n    Path { path in\n     path.move(to: CGPoint(x: geometry.size.width / 2, y: 100))\n     path.addLine(to: CGPoint(x: geometry.size.width / 2 - 50, y: 200))\n     path.addLine(to: CGPoint(x: geometry.size.width / 2 + 50, y: 200))\n    }\n    .stroke(style: StrokeStyle(lineWidth: 30, lineCap: .square, lineJoin: .round))\n   }\n  }\n```\n\n![lineJoin](/assets/images/project%20brainstorming.flavor%20flash%20journal.View.lineJoin.png)\n\n`strokeStyle` init parameters:\n\n1. lineCap: 控制線條尾端的形狀\n   1. round 圓尾\n   2. square、butt 方形尾\n      > 如果想要嚴格控制物件的大小 => butt，因為square的方形尾會超出起點＆終點\n\n2. lineJoin: 控制線條的連接style\n   1. round、milter、bevel\n3. dash: 控制虛線樣式&間隔的長度\n\n### 搭配`trim`做一個Loading的動畫\n\n```swift\nimport SwiftUI\nimport Combine\n\nstruct CircleView: View {\n\n @State var progress: CGFloat = 0\n let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()\n\n    var body: some View {\n      Circle()\n        .trim(from: 0.0, to: progress)\n        .stroke(Color.green, lineWidth: 20)\n        .frame(width: 200, height: 200)\n        .onReceive(timer, perform: { _ in\n          addProgress()\n   })\n }\n\n func addProgress() {\n  if progress >= 1.0 {\n   progress = 0.1\n  } else {\n   progress += 0.1\n  }\n }\n}\n```\n\nWithout using Combine ↓\n\n```swift\nstruct CircleView: View {\n\n @State var progress: CGFloat = 0\n\n    var body: some View {\n      Circle()\n        .trim(from: 0.0, to: progress)\n        .stroke(Color.green, lineWidth: 20)\n        .frame(width: 200, height: 200)\n        .onAppear {\n          let setTimer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { timer in\n            addProgress()\n          }\n        }\n }\n\n func addProgress() {\n  if progress >= 1.0 {\n   progress = 0.1\n  } else {\n   progress += 0.1\n  }\n }\n}\n```\n","n":0.065}}},{"i":30,"$":{"0":{"v":"Tips","n":1},"1":{"v":"\n## Preview\n\n可以建立static的function建立假的資料給Preview測試不同情境下畫面的顯示","n":0.707}}},{"i":31,"$":{"0":{"v":"Extensions","n":1},"1":{"v":"\n## `Color`\n\n```swift\nextension Color {\n  static func generateRandomColor() -> Self {\n  enum RColor: Int {\n    case red = 0, green = 1, blue = 2, yellow = 3\n\n    var color: Color {\n      switch self {\n      case .blue: return Color.blue\n      case .green: return Color.green\n      case .yellow: return Color.yellow\n      case .red: return Color.red\n      }\n    }\n  }\n\n  let random = Int.random(in: 0...3)\n\n  return RColor(rawValue: random)!.color\n  }\n}\n```\n","n":0.127}}},{"i":32,"$":{"0":{"v":"Animation","n":1},"1":{"v":"\n## 3 ways of implementing animation in swiftUI\n\n1. By `.animation` modifier\n\n    ```swift\n    struct PersonMoveView: View {\n\n    @State private var moveDistance: CGFloat = 0\n\n      var body: some View {\n      Button {\n        moveDistance += 100\n      } label: {\n        Text(\"移動\")\n      }\n\n      Image(.jason)\n        .resizable()\n        .scaledToFit()\n        .offset(x: moveDistance)\n        .animation(.bouncy, value: moveDistance)\n      }\n    }\n    ```\n\n2. `withAnimation`\n\n    ```swift\n        struct PersonMoveView: View {\n\n      @State private var moveDistance: CGFloat = 0\n\n        var body: some View {\n        let animation = Animation.easeInOut(duration: 0.2).delay(0.2).repeatForever(autoreverses: true)\n\n        Button {\n          moveDistance += 100\n        } label: {\n          Text(\"移動\")\n        }\n\n        Image(.jason)\n          .resizable()\n          .scaledToFit()\n          .offset(x: moveDistance)\n          .animation(.bouncy, value: moveDistance)\n          .onAppear {\n            withAnimation(animation) {\n              moveDistance += moveDistance == 100 ? -100 : 100\n            }\n          }\n        }\n    }\n    ```\n\n3. calling `animation` on `Binding` values\n\n## Transition\n\n1. 類似sheet的酷東東\n\n    ```swift\n    struct TransitionView: View {\n\n      @State private var showView: Bool = false\n\n      var body: some View {\n        ZStack(alignment: .bottom) {\n          VStack {\n            Button(\"Button test transition\") {\n              withAnimation(.easeInOut) {\n                showView.toggle()\n              }\n            }\n\n            Spacer()\n          }\n\n          if showView {\n            RoundedRectangle(cornerRadius: 30.0)\n              .frame(height: UIScreen.main.bounds.height * 0.5)\n              .transition(.move(edge: .bottom))\n          }\n        }\n        .ignoresSafeArea(edges: .bottom)\n        }\n    }\n    ```\n\n2. `asymmetric`可以做進出場的控制\n\n    ```swift\n    .transition(\n        AsymmetricTransition(\n            insertion: .move(edge: .bottom), removal: .move(edge: .trailing)))\n    ```\n\n### Transition vs Animation 的使用時機？\n\nview原本就在螢幕上，且單純想做搖擺等動畫 => animation\n\n要新增某個view到現有的view => Transition + conditional rendering\n\n## Sheet vs Transition vs Animation offset","n":0.072}}},{"i":33,"$":{"0":{"v":"Language","n":1}}},{"i":34,"$":{"0":{"v":"Swift","n":1}}},{"i":35,"$":{"0":{"v":"Tip","n":1},"1":{"v":"\n## Pretty print debug console\n\n- use \"dump\"\n\n## Local Reasoning\n\n## Data mapping\n\n### 將`[(value, value)]`格式的陣列，轉換成`Dictionary`\n\n","n":0.277}}},{"i":36,"$":{"0":{"v":"Protocol","n":1},"1":{"v":"\n## What is Protocol?\n\n> A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to conform to that protocol.\n\nProtocol是功能的藍圖，定義好可以交由Type實現功能。\n\n舉例來說，我們是老闆，我們再請工廠生產我們的產品之前，先給工廠一個產品的requirement，讓我們兩種不同產品，都提供一些相同功能。\n\nex: 可以旋轉、可以變色等等\n\n這些功能是我們的最低要求，我們請工廠一定在建立產品之前，要符合這些功能給我們產品的藍圖，再去實際生產\n\n## Why do we need Protocols?\n\n## Protocol Requirements\n\n### properties\n\n```swift\n\n```\n\n### functions\n\n- 如果用**mutating**標記function的草稿，在實作class method時不必再寫一次在method前，但struct, enum時需要。\n\n> 為什麼需要mutating標記呢？\n>\n> protocol 本身並不會實作function，只定義**名字**、**參數**、**回傳值**。 但是有時候還是很難透過這三個東西去表示這個function實作時需要注意的事，像是會不會去更改到該Type的stored properties，但如果用mutating前綴作為標記的話，就可以一目瞭然，知道這個function實作時會更改到stored property。\n\n```swift\nenum OnOffSwitch: Togglable {\n    case off, on\n    // class實作時不需要再標記為mutating\n    mutating func toggle() {\n        switch self {\n        case .off:\n            self = .on\n        case .on:\n            self = .off\n        }\n    }\n}\nvar lightSwitch = OnOffSwitch.off\nlightSwitch.toggle()\n```\n\n### initializers\n\n```swift\nprotocol SomeProtocol {\n    init(someParameter: Int)\n}\n// 實作時要加上`required`，但如果標記為`final`的class，則可以不必\nclass SomeClass: SomeProtocol {\n    required init(someParameter: Int) {\n        // initializer implementation goes here\n    }\n}\n```\n\n## Protocol vs Inheritance\n\nStruct, Enum 是無法被繼承的Type，但我們可以透過讓這些Type遵循某個共同的Protocol去讓Type之間有一些很相似的特性。\n\n## Note：\n\n- Protocol 也是一個類別\n\n> 有時候instance之間並沒有共同superclass，但是有共同的功能，這時候就可以透過protocol的type讓他們有以功能分類的概念。\n\n```swift\nlet objects: [AnyObject] = [Circle(radius: 10), Sun(radius: 100), Frisbee(radius: 50), Square(width: 10)]\n\nfor object in objects {\n  if let roundObject = object as? Round {\n    print(\"round object\")\n  } else {\n    print(\"not round\")\n  }\n}\n```\n\n- Protocol 可以其他 Protocol 繼承\n- Protocol 可以互相組合\n- -@objc protocols can be adopted only by classes, not by structures or enumerations\n- Protocol 搭配 extension 做","n":0.072}}},{"i":37,"$":{"0":{"v":"Sequence","n":1}}},{"i":38,"$":{"0":{"v":"Performance","n":1},"1":{"v":"\n## Dimensions of Performance\n\n1. Allocation\n   1. stack & heap\n2. Reference Counting\n3. Method Dispatch\n\n### Allocation\n\n記憶體儲存的位置，\n\n如果沒有identity, indirect storage的需求，使用struct會比class有更好的效能。\n\n#### Dynamic / Static Dispatch\n\n- Dynamic:\n  1. Table Dispatch(witness table)\n  2. Message Dispatch(KVO, Core Data)\n- Static:\n  1.","n":0.177}}},{"i":39,"$":{"0":{"v":"Memory Management","n":0.707},"1":{"v":"\nhttps://developer.apple.com/documentation/swift/manual-memory-management\n\n## Stack vs Heap\n\n他們都是記憶體區域\n\n### Stack 特性\n\n- **具有區域性:**\n\n  呼叫function時 function scope中的變數會被存在stack中，當執行完畢會釋放\n\n- **堆疊結構:**\n\n  stack 是一種堆疊結構，讀寫stack上的資料可以非常迅速\n\n- **自動分配和釋放:**\n\n  想想function，我們從來沒有主動去釋放function內宣告的變數，只要變數超過作用域，空間就會被自動釋放\n\n### Heap 的特性\n\n- **動態分配:**\n\n  在heap上分配記憶體是動態的，它不像 stack 那樣有明確的作用範圍和生命週期\n\n- **生命週期:**\n\n  heap上的資料不受作用域限制，可以依據程式的需求進行調整\n\n- **全局性:**\n\n  heap上的資料可以在整個應用程式中共享\n\n### Heap Summary\n\n- More dynamic but less efficient than stack.\n- Goes through 3 steps:\n  1. allocation\n  2. tracking reference count\n  3. deallocation\n- Heap memory allocation is done for objects whose size can not be calculated at compile time, plus all reference types(because reference types life time is not based on their defined scope).\n- heap memory is somehow a global host for objects and all threads can have access to it, so the objects stored on it are not thread-safe\n\n### Stack Summary\n\n- value types are all stored on the stack memory. Note that the value types should not have any reference types associated with them(i.e. they are either not contained by or contain a reference type) otherwise they wouldn’t be stored on the stack.\n- The amount of memory needed is normally calculated at compile time since they are not dynamic and do not need reference count semantics to decide how long they have to live(They live in a scope and when they are used the memory will dump them)","n":0.072}}},{"i":40,"$":{"0":{"v":"ARC","n":1},"1":{"v":"\n## What is ARC (Automatic Reference Counting)?\n\n> Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.\n\n從官方文件可以得知，他是一個跟物件(class)生命週期有關的自動化機制。\n\n## How ARC Works in Example\n\n```swift\nclass Person {\n    let name: String\n\n    init(name: String) {\n        self.name = name\n        print(\"\\(name) is initialized\")\n    }\n\n    deinit {\n        print(\"\\(self.name) is deinitialized\")\n    }\n}\n\nvar reference1: Person?\nvar reference2: Person?\nvar reference3: Person?\n\n// Jason person object reference count = 0\nreference1 = Person(name: \"Jason\") // count = 1\nreference2 = reference1 // count = 2\nreference3 = reference1 // count = 3\n\nreference2 = nil // count = 2\nreference3 = nil // count = 1\n//reference1 = nil\n// comment out this line of code so that count = 0.\n// ARC deallocates this Jason person object's memory,\n// since there are no more strong reference\n```\n\n## Strong reference Example\n\n![strong ref establish](/assets/images/programming.language.swift.ARC_strong-ref_1.png)\n\n![remove variable references](/assets/images/programming.language.swift.ARC_strong-ref_2.png)\n\n可以發現儘管`john`跟`ApartmentA`都沒有再引用到Person、Apartment實例，但是因為這兩個實例本身互相引用了，導致Reference Count沒有辦法歸零並釋放記憶體，進一步造成memory leak。\n\n## How to prevent reference cycle?\n\n> Swift provides two ways to solve reference cycles when working with a class type: weak references, and unowned references .\n\n評估物件的生命週期適合用`weak` 還是 `unowned`\n\n```swift\n\n// 使用weak原因：StorageManager實例調用saveImage時，\n// 我們不確定delegate的物件是否已經deallocated, 所以使用weak。\n// 如果很確定delegate的物件不會被deallocated，我們可以使用unowned\nclass StorageManager {\n    weak var delegate: StorageManagerDelegate?\n\n    public func saveImage() {\n        var imageData: Data\n        // fetch image...\n\n\n        self.delegate?.didReceiveImage(self, imageData)\n    }\n}\n\n```\n\n## Closure也是Reference Type，所以也會有 reference cycle\n\n> 透過定義 capture list 來明確指定外部變數的捕獲方式。","n":0.067}}},{"i":41,"$":{"0":{"v":"Grand Central Dispatch","n":0.577},"1":{"v":"\n![GCD_icon](/assets/images/language.swift.grand-central-dispatch_icon.png)\n\n```mermaid\ngraph TB;\nA[Grand Central Dispatch] --> B[Why do we need it?]\nA --> C[How did it work?]\nA --> D[Alternatives]\n```\n\n## What is Grand Central Dispatch?\n\n> Dispatch, also known as Grand Central Dispatch (GCD), contains language features, runtime libraries, and system enhancements that provide systemic, comprehensive improvements to the support for concurrent code execution on multicore hardware in macOS, iOS, watchOS, and tvOS.\n\n一個讓工程師可以更輕易配置**concurrent code**的框架\n\n## What problem did **GCD** solve?\n\n執行緒管理 | 人工 | GCD\n---------|----------|---------\n (維護 / 開發)難度 | 較高  | 較低\n 平均效能 | 1 | 1.3\n 安全性 | 不一定 | 安全\n\n## How did it Work?\n\nGCD是一個讓我們可以不用直接操作Thread的API，我們只需要指定Task的**性質**，並將他加入適當的**DispatchQueue**，GCD就可以幫我們處理這些Task應該要在哪個Thread被執行。\n\n### Before GCD\n\n```mermaid\ngraph TD\nA[Program] --> B[Create Threads]\nB --> C[Define Thread Functions]\nC --> D[Start Threads]\nD --> E[Thread1: Task1]\nD --> F[Thread2: Task2]\nD --> G[Thread3: Task3]\nE --> H[Thread Synchronization]\nF --> H\nG --> H\nH --> I[Continue Execution]\n```\n\n### After GCD\n\n```mermaid\ngraph TD\nA[Program] --> B[Dispatch Queue1]\nA[Program] --> C[Dispatch Queue2]\nB --> D[Task1]\nB --> E[Task2]\nC --> F[Task3]\nC --> G[Task4]\n```\n\n## Parallelism and Concurrency\n\n> ### Explaination from WWDC2017 GCD\n>\n> - Parallelism\n>\n>   Simultaneous execution of closely related computations\n> - Concurrency\n>\n>   Composition of independently executed tasks\n\n## Queue Concept\n\n當我們提交Task到DispatchQueue中，GCD會依照先進先出(FIFO)的規則依序執行我們的Task。\n\n我們僅需要注意：\n\n- 選擇對的DispatchQueue( Serial / Concurrent )\n- 執行對的dispatching function( sync / async )\n\n### DispatchQueue\n\n#### Serial vs Concurrent\n\nDispatchQueue Type | Serial | Concurrent\n---------|:----------:|:---------:\n 可預測 | 可以 | 不一定\n 發生Race Condition | 不可能 | 可能\n 完成Task的速度 | 慢 | 快\n\n#### Sync vs async\n\n> Dispatch Function is just a function that tells the queue how this task should be scheduled\n\n```swift\nlet backgroundQueue = DispatchQueue.global()\nbackgroundQueue.sync {\n  // Task1\n  print(\"task1\")\n}\n\nprint(\"between sync\")\n\nbackgroundQueue.async {\n  // Task2\n  print(\"task2\")\n}\n\n// output:\n// task1\n// between sync\n// task2\n```\n\n```swift\nlet backgroundQueue = DispatchQueue.global()\nbackgroundQueue.async {\n  // Task1\n  print(\"task1\")\n}\n\nprint(\"middle\")\n\nbackgroundQueue.sync {\n  // Task2\n  print(\"task2\")\n}\n\nprint(\"bottom\")\n\n// output:\n// between async\n// task2\n// after all async\n// task1\n```\n\n```swift\nlet backgroundQueue = DispatchQueue.global()\nbackgroundQueue.async {\n  // Task1\n  print(\"small task done, on thread \\(Thread.current)\")\n  backgroundQueue.sync {\n    print(\"sync task, on thread \\(Thread.current)\")\n    backgroundQueue.async {\n      print(\"inside sync async task, on thread \\(Thread.current)\")\n    }\n  }\n}\n\nprint(\"between async\")\n\nbackgroundQueue.sync {\n  // Task2\n  print(\"task2\")\n}\n\nprint(\"after all async\")\n\n// output:\n// between async\n// task2\n// after all async\n// task1\n```\n","n":0.058}}},{"i":42,"$":{"0":{"v":"Parallelism","n":1},"1":{"v":"\n## 明確告訴GCD這個task要使用parellelism的方式去執行\n\n`DispatchQueue.concurrentPerform`","n":0.707}}},{"i":43,"$":{"0":{"v":"Concurrency","n":1},"1":{"v":"\n## 為什麼我們要好好的處理concurrency?\n\n設計良好的concurrency code可以讓我們充分使用到CPU的資源\n\n## 如何使用DispatchQueue?\n\n**DispatchQueue**就是幫我們管理Tasks的一個物件。\n\n### Step 1: 取得或建立一個DispatchQueue\n\n```swift\nlet mainQueue = DispatchQueue.main  // Serial\n\nlet globalQueue = DispatchQueue.global() // Concurrent\n\nlet customQueue = DispatchQueue(label: \"example.com.domain\") // default Serial\n```\n\n### Step 2: 我們可以透過以下方式提交Task到一個DispatchQueue物件上，並指定DispatchQueue要如何執行這個Task\n\n```swift\nglobalQueue.sync {\n  // Task1...\n}\n\nglobatQueue.async {\n  // Task2...\n}\n```\n\n## 什麼是DispatchItem？為何要使用他？\n\n如果我們想要控制我們的Task狀態呢？ ex: 在三秒內沒有回傳結果時我想要取消這個Task\n\n  1. 情境1:  使用者輸入UISearchBar時，不希望每次text change都打一次API，造成後端的負擔。\n\n      我們可以將Task透過DispatchItem封裝，再透過DispatchQueue設定asyncAfter延後執行這個DispatchItem，我們就可以達到延遲fetch資料，減少對後端的負載\n\n\n```swift\nlet workItem = DispatchWorkItem {\n  // Task1...\n}\n\nglobalQueue.async(execute: workItem)\n```\n\n## 什麼是DispatchGroup? 為何要使用他？\n\n  1. 情境1: 我們有一個陣列的api要打，我們希望他可以全部加載完再一次更新到畫面上\n\n```swift\nlet globalQueue = DispatchQueue.global()\nlet loadImageGroup = DispatchGroup()\n\nloadImageGroup.enter()\nglobalQueue.async {\n    task1() { response in\n        ...\n        loadImageGroup.leave()\n    }\n}\n\nloadImageGroup.enter()\nglobalQueue.async {\n    task2() { response in\n        ...\n        loadImageGroup.leave()\n    }\n}\n\n// 1. wait synchronously for all tasks to finish\nloadImageGroup.wait()\n// ↓ Tasks that need to be done after loadImageGroup's task are all done\nprint(\"all done\")\n\n\n// 2. adding a completion handler for loadImageGroup\nloadImageGroup.notify(queue: .main) {\n  // ui update code\n}\n\n```\n\n## 什麼是DispatchSemaphore？為何要使用他？\n\n## 什麼是Barrier？為何要使用他？\n\n當把Task加到Concurrent Queue中，有時候不同Thread的Task會需要共同存取+修改到某個Value，造成一些Bug。\n\n透過在submit一個task時設定這個Task被執行時不能有其他task存取到同一個共同資源，可以確保這個task執行時不會有其他存取到共同資源的Task在其他Thread中存取。\n\n![](/assets/images/language.swift.grand-central-dispatch.concurrency_barrierConcept.png)","n":0.094}}},{"i":44,"$":{"0":{"v":"Generics","n":1},"1":{"v":"\n適當的使用泛型可以確保我們的程式碼可讀性、重用性。\n\n```swift\nlet intArray = [1, 2, 2, 3, 3, 3]\nlet stringArray = [\"one\", \"two\", \"two\", \"three\", \"three\", \"three\"]\n\nfunc count<T: Hashable>(of element: T, in array: [T]) -> Int? {\n    let mappedItems = array.map { ($0, 1) }\n    let counts = Dictionary(mappedItems, uniquingKeysWith: +)\n    return counts[element]\n}\n\ncount(of: 2, in: intArray)\ncount(of: \"two\", in: stringArray)\n```","n":0.143}}},{"i":45,"$":{"0":{"v":"Framework","n":1}}},{"i":46,"$":{"0":{"v":"URL Loading System","n":0.577}}},{"i":47,"$":{"0":{"v":"Combine","n":1},"1":{"v":"\n## What is Combine?\n\nCombine框架是一個響應式框架，它可以處理asynchronous事件，例如用户交互，網路響應等。Combine使用了發布者和訂閱者模型，發布者發布事件，訂閱者接收並處理這些事件。","n":0.5}}},{"i":48,"$":{"0":{"v":"SwiftUI","n":1}}},{"i":49,"$":{"0":{"v":"property wrappers","n":0.707},"1":{"v":"\n> Property Wrapper跟SwiftUI是同一年推出的，導致很多人會誤以為property wrapper也是SwiftUI框架中的一部份，但其實只是一個swift語言 5.1 的新功能。\n\n## What is Property Wrappers?\n\nThe `@propertyWrapper` is a Swift attribute used on structs, enums or classes\n\n> Property wrappers 是一個語法糖，告訴compiler說這個類別建立出來的實體有wrapped value這層setter / getter的包裝。\n\nREF: https://www.hackingwithswift.com/quick-start/swiftui/all-swiftui-property-wrappers-explained-and-compared\n\n1. `@AppStorage`: (Owns its data)\n   1. A easier way to manage userDefaults in swiftUI.\n2. `@Binding`: (Doesn't own its data)\n3. `@Environment`:\n   1. Reads data from the system. (ex: Color scheme, scenePhase)\n4. `@EnvironmentObject`: (Doesn't own its data)\n   1. Reads a shared Object that we placed into the environment.\n5. `@State`: (Owns its data)\n   1. Lets us manipulate small amounts of value type data locally to a view.\n6. `@StateObject`: (Owns its data)\n   1. Used to store new instances of reference type data that conforms to the `ObservableObject` protocol.\n7. `@ObservedObject`: (Doesn't own its data)\n   1. Refers to an instance of an external class that conforms to the `ObservableObject` protocol.\n8. `@Published`: (Owns its data)\n   1. Is attached to properties inside an 1, and tells SwiftUI that it should refresh any views that use this property when it is changed.","n":0.079}}},{"i":50,"$":{"0":{"v":"State","n":1},"1":{"v":"\n## What is `@State`?\n\n> A property wrapper type that can read and write a value managed by SwiftUI.\n\n## When to use it?\n\n> Use state as the single source of truth for a given value type that you store in a view hierarchy. Create a state value in an ``App``, ``Scene``, or ``View`` by applying the `@State` attribute to a property declaration and providing an initial value\n\n## Behind the scene\n\n> SwiftUI manages the property's storage. When the value changes, SwiftUI updates the parts of the view hierarchy that depend on the value. To access a state's underlying value, you use its `wrappedValue` property. However, as a shortcut Swift enables you to access the wrapped value by referring directly to the state instance.\n\nSwiftUI 中每個View都是以struct定義的，由於struct中的property是immutable，如果我們有一個variable是會改變的，而每次改變時我們希望View會重繪，那這時候我們就可以用`@State`這個SwiftUI定義好的property wrapper。當我們更改這個以`@State`定義的variable，SwiftUI就會幫我們更新View。\n\n在struct中宣告變數加上`@State`前綴，SwiftUI會將這個變數管理在一個shared storage(Redux like)，讓我們在View的重繪時不會遺失這個變數。\n\n從SwiftUI documentation可以看到`@State`定義的一些public property：\n\n```swift\n@propertyWrapper public struct State<Value>: DynamicProperty {\n    public init(wrappedValue value: Value)\n\n    public init(initialValue value: Value)\n\n    public var wrappedValue: Value { get nonmutating set }\n\n    public var projectedValue: Binding<Value> { get }\n}\n\npublic protocol DynamicProperty {\n\n    /// Updates the underlying value of the stored value.\n    ///\n    /// SwiftUI calls this function before rendering a view's\n    /// ``View/body-swift.property`` to ensure the view has the most recent\n    /// value.\n    mutating func update()\n}\n```","n":0.072}}},{"i":51,"$":{"0":{"v":"Published","n":1},"1":{"v":"\n## `ObservableObject` Protocol\n\n當我們宣告一個class遵守`ObservableObject` protocol時，我們是在告訴SwiftUI這個class可以被View所觀測。\n\n這個class中如果有property使用`@Published`標記，代表這當這個property變動時，所有引用到這個property的View都要重繪。\n\n## When to use it?\n\n> whenever an object with a property marked `@Published` is changed, all views using that object will be reloaded to reflect those changes.\n\n## Behind the scenes\n\n> the `@Published` property wrapper effectively adds a willSet property observer to items, so that any changes are automatically sent out to observers.","n":0.135}}},{"i":52,"$":{"0":{"v":"EnvironmentObject","n":1},"1":{"v":"\n## Why use it?\n\n當我們想要在View Hiearchy中共享某個物件，不想要一層一層傳遞該物件時，我們可以在View的最父層透過`environmentObject()`modifier，讓要使用的子層在View中以`@EnvironmentObject`去取得這個共享的物件。\n\n## What is it?\n\n他跟`@ObservedObject`有點像，都是參照符合`ObservableObject`protocol 的物件，差別在於:\n\n- `@ObservedObject`需要父層傳遞該Observable物件\n- `@EnvironmentObject`則是找到在到View階層環境中的Observable物件。\n  > SwiftUI會找尋該View階層中與宣告型別一樣的物件。\n\n## Behind the scenes\n\n## Example\n","n":0.243}}},{"i":53,"$":{"0":{"v":"StateObject","n":1},"1":{"v":"\n## What is `@StateObject`\n\n> A property wrapper type that instantiates an observable object.\n\n## When to use it?\n\n> Use a state object as the single source of truth for a reference type that you store in a view hierarchy.\n>\n> when you need to create a reference type inside one of your views and make sure it stays alive for use in that view and others you share it with.\n\n## Behind the scenes\n\n## Injecting `@StateObjects` into views\n\n```swift\nstruct MyInitializableView: View {\n    @StateObject private var model: DataModel\n    init(name: String) {\n        // SwiftUI ensures that the following initialization uses the\n        // closure only once during the lifetime of the view, so\n        // later changes to the view's name input have no effect.\n        _model = StateObject(wrappedValue: DataModel(name: name))\n    }\n    var body: some View {\n        VStack {\n            Text(\"Name: \\(model.name)\")\n        }\n    }\n}\n```\n\n## Force `@StateObject` property to reinitialize\n\n如果希望View中的reference type在View重繪時重新初始化，可以透過給定id modifier的方式去強迫這個reference type重新初始化（一般來說重繪View時，如果View的id沒有變化，SwiftUI就不會重新初始化這個 reference type property）\n\n## iOS 17.0 introduced `@Observable` macro\n\n- 使用`@Observable` macro 帶來什麼好處？\n\n  1. 寫更少扣：\n     1. 只要class前面帶有`@Observable`，裡面宣告的變數都帶有`@Published`特性。\n     2. 在View中初始化該class的實體不需要標記為`@StateObject`。\n     3. 該class也不需要在定義時標記遵守 `ObservableObject`。","n":0.079}}},{"i":54,"$":{"0":{"v":"Environment","n":1},"1":{"v":"\n## Why use it?\n\n有時候我們會需要取得一些裝置、系統設定的資訊如：\n\n- colorScheme 當前系統 深 / 淺 色\n- managedObjectContext CoreData的viewContext\n\n透過`@Environment`我們可以很輕鬆取得這些資訊\n\n## What is it?\n\n他是一個可以用來取得一些SwiftUI預設宣告好的物件。\n\n## Difference between `@EnvironmentObject`\n\n- `@EnvironmentObject` allows us to inject arbitrary values into the environment.\n\n- `@Environment` is specifically there to work with SwiftUI’s own pre-defined keys.\n\n## Behind the scenes","n":0.154}}},{"i":55,"$":{"0":{"v":"Extension","n":1},"1":{"v":"\n## What can we do with Extension?\n\nAdd functionality for class, struct, enum.\n\n- 透過extension，我們可以擴展非open source的程式碼。\n\n## Why can't we add stored properties into Extension?\n\n- 影響程式碼的可維護性、可讀性\n- 記憶體存放考量，stored properties是需要額外分配記憶體空間去儲存的。\n- Swift是安全、強型別語言，如果允許在Extension中聲明stored properties，會需要在compile的時候引入type check, type inference，增加複雜度。\n\n如果有想要在某Type的Extension中宣告stored properties的衝動，你或許該考慮繼承該Type。\n\n## Why can we add static properties inside a type's Extension?\n\n當我們在類別的宣告中聲明一個static property，這個static property就是一個放在該類別namespace底下的global property。\n\n```swift\nclass Person {\n    let name: String\n\n    let age: Int\n\n}\n\nextension Person {\n    static let john = Person(name: \"John\", age: 18)\n}\n\n// 想在程式碼任何地方取用時\nPerson.john\n```","n":0.126}}},{"i":56,"$":{"0":{"v":"Tips","n":1},"1":{"v":"\n## computed property設計\n\n```swift\nextension String {\n    var firstLetter: Character {\n        get {\n            return self.count > 0 ? self[self.startIndex] : \" \"\n        }\n\n        set {\n            if self.count > 0 {\n                self.replaceSubrange(self.startIndex...self.startIndex, with: String(newValue))\n            } else {\n                self.append(newValue)\n            }\n        }\n    }\n}\n```","n":0.162}}},{"i":57,"$":{"0":{"v":"UIImage","n":1},"1":{"v":"\n```swift\nfunc resize(size: CGSize) -> UIImage? {\n  UIGraphicsBeginImageContext(size)\n  draw(in: CGRect(x: 0, y: 0, width: size.width, height: size.height))\n  let image = UIGraphicGetImageFromCurrentImageContext()\n  UIGraphicsEndImageContext()\n  return image\n}\n```","n":0.209}}},{"i":58,"$":{"0":{"v":"Data Structure","n":0.707},"1":{"v":"\n\n## What does conforming to **Codable** do?\n\n```swift\nstruct Landmark: Codable {\n    var name: String\n    var foundingYear: Int\n\n    // Landmark now supports the Codable methods init(from:) and encode(to:),\n    // even though they aren't written as part of its declaration.\n}\n```\n\n遵循Codable協議就可以在編碼或解碼資料時，將資料轉成swift的資料格式\n\n## 搭配 **CodingKeys** 做 encode, decode\n\n如果api回傳的資料(encoded的格式)跟我們的struct定義不一致，我們可以提供自定義的encode, decode邏輯。\n\n## JSONSerialization\n\n> An object that converts between JSON and the equivalent Foundation objects.\n\n## `Decodable` vs `Decoder` Protocol\n\n`Decodable`是一個Protocol，並要求遵守的類必須提供一個`init()`，而這個`init`函式的唯一input是一個`Decoder`類\n\n```swift\n/// A type that can decode itself from an external representation.\npublic protocol Decodable {\n\n    /// Creates a new instance by decoding from the given decoder.\n    ///\n    /// This initializer throws an error if reading from the decoder fails, or\n    /// if the data read is corrupted or otherwise invalid.\n    ///\n    /// - Parameter decoder: The decoder to read data from.\n    init(from decoder: Decoder) throws\n}\n```\n\n`Decoder`也是一個Protocol，我們使用遵守他的類來解碼payload。\n\n範例：\n\n當我們自定義Decoder的初始化函式時，我們透過`Decoder`實體的`container()` func拿到一個`KeyedDecodingContainer`的實體，並利用這個`container`的`decode()`來解碼payload。\n\nＱ： CodingKeys 扮演什麼角色？\n\nＡ： Decoder呼叫container時需要傳入CodingKeys這個類，之後就可以透過container的`decode`去取值。\n\n```swift\nstruct Person: Decodable {\n    let name: String\n    let age: Int\n    let gender: String\n\n    enum CodingKeys: CodingKey {\n        case name\n        case age\n        case gender\n    }\n\n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        self.name = try container.decode(String.self, forKey: .name)\n        self.age = try container.decode(Int.self, forKey: .age)\n        self.gender = try container.decode(Gender.self, forKey: .gender).rawValue\n    }\n}\n\nenum Gender: String, Decodable {\n    case male\n    case female\n}\n```","n":0.073}}},{"i":59,"$":{"0":{"v":"Closures","n":1},"1":{"v":"\n## Capture list 情境\n\n### 捕獲的變數為 value type\n\n```swift\n/// closure capture value at define\nvar captureValue = 20\n\nlet captureFunction = { [captureValue] in\n    print(\"captured value: \\(captureValue)\")\n}\n\ncaptureValue = 100\ncaptureFunction() // 20\n```\n\n⇧ 的code跟 ↓ 是等價的，只是用capture list更簡潔。\n\n```swift\nvar captureValue = 20\nvar capturedClosureValue = captureValue\n\nlet captureFunction = {\n    print(\"captured value: \\(capturedClosureValue)\")\n}\n\ncaptureValue = 100\ncaptureFunction() // 20\n```\n\n```swift\n/// closure capture value at execution\nvar captureValue = 20\n\nlet captureFunction = {\n    print(\"captured value: \\(captureValue)\")\n}\n\ncaptureValue = 100\ncaptureFunction() // 20\n```","n":0.124}}},{"i":60,"$":{"0":{"v":"Types","n":1},"1":{"v":"\n## Definition\n\n- class, struct\n\n> Model custom types that encapsulate data.\n\n- enum\n\n> Model custom types that define a list of possible values.\n\n## Value Type , Reference Type\n\n差異在於它們在記憶體中的儲存和管理方式\n\n### value type:\n\n- 通常較小，且輕量，因為儲存的是實際數據的`值`，可以直接存在`Stack`上\n- pass by value\n\n![value type](/assets/images/programming.language.swift.Types.value-type.png)\n\n### reference type:\n\n- 可能較大，因為儲存的是對實際數據的`引用`，可能會包含其他資訊(類型訊息、ARC相關訊息)\n- pass by reference\n\n![reference type](/assets/images/programming.language.swift.Types.reference-type.png)\n","n":0.158}}},{"i":61,"$":{"0":{"v":"Structures Vs Classes","n":0.577},"1":{"v":"\n在swift語言中，用struct跟class宣告的custom type能達到幾乎一樣的功能。\n\n## Definition Syntax\n\n```swift\nstruct SomeStructure {\n\n}\n\nclass SomeClass {\n\n}\n```\n\n## Examples\n\n```swift\nstruct LocationStruct {\n    var latitude: CGFloat\n    var longitude: CGFloat\n}\n\nclass LocationClass {\n    var latitude: CGFloat\n    var longitude: CGFloat\n\n    init(latitude: CGFloat, longitude: CGFloat) {\n       self.latitude = latitude\n       self.longitude = longitude\n    }\n}\n\nlet locationStruct = LocationStruct(latitude: 120, longitude: 25)\n\nlet locationClass = LocationClass(latitude: 120, longitude: 25)\n\n```\n\n## Both can:\n\n- 定義store properties, computed properties\n- 定義methods\n- 用extension來擴展他們的功能\n- 定義subscripts，讓我們可以透過`[]`的方式取得值\n\n## DIFF\n\n### **Pass by value** vs **Pass by reference**\n\n#### CoA （Copy-on-Assign）\n\n```swift\nstruct PersonStruct {\n    var name: String\n    var age: Int\n}\n\nvar firstPerson = PersonStruct(name: \"StructPerson\", age: 18)\nvar secondPerson = firstPerson\n\nfirstPerson.name = \"StructPersonModified\"\n\nprint(firstPerson.name)\nprint(secondPerson.name)\n\ngetStackAddress(target: &firstPerson) == getStackAddress(target: &secondPerson)\n```\n\n#### CoW （Copy-on-Write）\n\n```swift\nvar personStructArray = [\n    PersonStruct(name: \"TOYX\", age: 18),\n    PersonStruct(name: \"TOYY\", age: 18),\n    PersonStruct(name: \"TOYZ\", age: 18),\n]\nvar personStructArrayCopy = personStructArray\n\ngetStackAddress(target: &personStructArray) == getStackAddress(target: &personStructArrayCopy)\n\npersonStructArrayCopy[0].name = \"TOYA\"\n\ngetStackAddress(target: &personStructArray) == getStackAddress(target: &personStructArrayCopy)\n```\n\n![value type](/assets/images/programming.language.swift.Types.value-type.png)\n\n#### Reference\n\n```swift\nclass PersonClass {\n    var name: String\n    var age: Int\n\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n}\n\nvar thirdPerson = PersonClass(name: \"ClassPerson\", age: 20)\nvar fourthPerson = thirdPerson\n\nthirdPerson.name = \"ClassPersonModified\"\n\nprint(thirdPerson.name)\nprint(fourthPerson.name)\nprint(thirdPerson === fourthPerson)\n```\n\n![reference type](/assets/images/programming.language.swift.Types.reference-type.png)\n\n## Static Dispatch vs Dynamic Dispatch\n\n### Method dispatch\n\nd | initial Declaration | Extension\n---------| :----------: |:---------:\n Value Type(struct, enum) | Static | Static\n Protocol | Table | Static\n Class | Table | Static\n NSObject Subclass | Table | Message\n\n- Dynamic dispatch example\n\n    ```swift\n    protocol Dispatch {\n        func testDispatch()\n    }\n\n    extension Dispatch {\n        func shared() {\n            print(\"\\(#function) from protocol extension\")\n        }\n    }\n\n    class A: Dispatch {\n      func testDispatch() {\n        print(\"\\(#function) from A\")\n      }\n    }\n\n    class B: A {\n        override func testDispatch() {\n            print(\"\\(#function) from B\")\n        }\n\n        func shared() {\n            print(\"\\(#function) from B\")\n        }\n    }\n\n    let a: A = B()\n\n    a.testDispatch()\n    a.shared()\n    ```\n\n```swift\n// 1. Value Type (Struct): All Static Dispatch\nstruct Person {\n    func isHungry() -> Bool { } // Static\n}\nextension Person {\n    func sayHello() -> String { } // Static\n}\n\n// 2. Protocol: Table & Static\nprotocol Animal {\n    func isCute() -> Bool { } // Table\n}\nextension Animal {\n    func canGetAngry() -> Bool { } // Static\n}\n\n// 3. Class\nclass Dog: Animal {\n    func isCute() -> Bool { } // Table\n    // add @objc & dynamic keyword\n    @objc dynamic func hoursSleep() -> Int { } // Table -> Message\n}\nextension Dog {\n    func canBite() -> Bool { } // Static\n    // add @objc keyword\n    @objc func goWild() { } // Static -> Message\n}\n// add final keyword\nfinal class Employee {\n    func canCode() -> Bool { } // Table -> Static\n}\n```\n\n## Which to choose?\n\n> The additional capabilities that classes support come at the cost of increased complexity. As a general guideline, prefer structures because they’re easier to reason about, and use classes when they’re appropriate or necessary. In practice, this means most of the custom types you define will be structures and enumerations.\n\n- Use Classes When You Need Objective-C Interoperability\n- Use Classes When You Need to Control Identity\n\n如果我們沒有要使用到class比struct多擁有的特性，我們在開發的時候建議都以struct、enum建立Type，因為他們比較好local reason，可以確保程式碼的可讀性、維護性。\n\n## Situations when choosing different data types\n\n1. Structs:\n   1. Data Models\n   2. SwiftUI Views\n\n2. Classes:\n   1. ViewModels\n\n3. Actors:\n   1. Shared 'Manager' / 'Data Store'\n\n## Comparison\n\ntypes | Struct | Class | Actor | Enum\n---------|:----------:|:---------:|:--------:|:------:|\n Stored in | Stack | Heap | Heap | Stack\n copy by | Value | Reference | Reference | Value\n Thread safe | V | X | V | V\n Inheritance | X | V | X | X\n\nReferences:\n\n- https://www.backblaze.com/blog/whats-the-diff-programs-processes-and-threads/","n":0.044}}},{"i":62,"$":{"0":{"v":"Enumeration","n":1},"1":{"v":"\n## What is enum?\n\n是一個列舉型別，可以用來建立**有限**且**相關**的值集合\n\n## Declaration\n\n```swift\nenum Direction: String {\n    case north = \"N\"\n    case south = \"S\"\n    case west = \"W\"\n    case east = \"E\"\n}\n```\n\n## 用enum的優勢\n\n- Type Safety → compile-time check\n\n- Readability & Maintainability: 減少其他人看code需要的通靈技能\n\n    ```swift\n    enum Animal {\n        case mammal(name: String, legs: Int)\n        case bird(name: String, wingspan: Double)\n        case fish(name: String, color: String)\n    }\n\n    let lion = Animal.mammal(name: \"Lion\", legs: 4)\n    let eagle = Animal.bird(name: \"Eagle\", wingspan: 2.5)\n    let goldfish = Animal.fish(name: \"Goldfish\", color: \"Gold\")\n    ```\n\n- Extensibility：可以輕鬆擴展 / 修改 case value\n\n  ```swift\n  enum Animal {\n        case mammal(name: String, legs: Int)\n        case bird(name: String, wingspan: Double)\n        case fish(name: String, color: String)\n        case reptile(name: String, scales: Bool)  // Add reptile type\n    }\n  ```\n\n## Use Cases\n\n1. 表示狀態\n\n    ```swift\n    enum OrderStatus {\n        case pending\n        case processing\n        case shipped\n        case delivered\n        case cancelled\n    }\n    ```\n\n2. 搭配`associated value`當作容器：\n\n    ```swift\n    // 1. 定義 Message 容器\n    enum Message: Codable {\n        enum MediaType: String, Codable {\n            case image\n            case video\n            case audio\n        }\n\n        case text(payload: String)\n        case media(type: MediaType, payload: Data)\n    }\n\n    // 2. 建立 Message instance\n    let message: Message = .text(payload: \"Hello\")\n    let imageMessage: Message = .media(type: .image, payload: Data())\n\n    // 3. 取出 Message 容器內的 data\n    convertMessage(message)\n    convertMessage(imageMessage)\n\n    func convertMessage(_ message: Message) {\n        switch message {\n        case .text(let text):\n            print(\"this is a text message: \\(text)\")\n        case let .media(media, payload):\n            print(\"this is \\(media) message with Data: \\(payload)\")\n        }\n    }\n    ```","n":0.067}}},{"i":63,"$":{"0":{"v":"Class","n":1},"1":{"v":"\n## Declare a class\n\n```swift\nclass Size {\n    var width: Int = 10\n    var height: Int = 10\n}\nSize()\n```\n\n## Initialize a class instance\n\n- stored property with `default value`\n\n  ```swift\n  class Size {\n      var width: Int = 10\n      var height: Int = 10\n  }\n\n  var size = Size()\n  ```\n\n- set up stored property values in `init` function\n\n  ```swift\n  class Size {\n      var width: Int\n      var height: Int\n\n      init() {\n        width = 10\n        height = 10\n      }\n\n      init(width: Int, height: Int) {\n        self.width = width\n        self.height = height\n      }\n  }\n\n  var size1 = Size(width: 10, height: 10)\n  var size2 = Size()\n  ```\n\n- stored property with `optional value`\n\n    ```swift\n  class Size {\n      var width: Int?\n      var height: Int?\n  }\n\n  var size = Size()\n  size.width = 10\n  size.height = 10\n  ```\n\n- failable initializer\n\n  ```swift\n  class Size {\n      var width: Int\n      var height: Int\n\n      init() {\n          width = 10\n          height = 10\n      }\n\n      init?(width: Int, height: Int) {\n          self.width = width\n          self.height = height\n\n          if width <= 0 || height <= 0 {\n            return nil\n          }\n      }\n  }\n\n  var size1 = Size(width: -10, height: 10) // nil\n  var size2 = Size(width: 10, height: 10) // { width: 10, height: 10 }\n  ```\n\n## Property\n\n1. `stored property`\n\n    ```swift\n    class Size {\n        var width: Int = 10\n        var height: Int = 10\n        var x: Int = 0\n        var y: Int = 0\n    }\n    ```\n\n2. `computed property`\n   1. getter(must) / setter(optional)\n\n    ```swift\n    class Size {\n        var width: Int = 10\n        var height: Int = 10\n        var x: Int = 0\n        var y: Int = 0\n\n        var centerX: Int {\n            get {\n                return x + width / 2\n            }\n            set {\n                x = newValue - width / 2\n            }\n        }\n\n        var centerY: Int {\n            get {\n                return y + height / 2\n            }\n            set {\n                y = newValue - height / 2\n            }\n        }\n    }\n    ```\n\n3. property observer\n\n    ```swift\n    class Size {\n        var width: Int = 10 {\n            willSet {\n                newValue <= 0 {\n                    // do something\n                }\n            }\n            didSet {\n                if width <= 0 {\n                    width = oldValue\n                }\n            }\n        }\n\n        var height: Int = 10\n        var x: Int = 0\n        var y: Int = 0\n    }\n    ```\n\n4. `lazy` delay initialization\n\n## method\n\n- 沒有`input`但有`return value` → 可以考慮用computed property 讓 code更簡潔\n\n    ```swift\n    class Size {\n        var width: Int = 10\n        var height: Int = 10\n        var x: Int = 0\n        var y: Int = 0\n\n        func description() -> String {\n            return \"\\(width) x \\(height)\"\n        }\n    }\n\n    class Size {\n        var width: Int = 10\n        var height: Int = 10\n        var x: Int = 0\n        var y: Int = 0\n\n        var description: String {\n            \"\\(width) x \\(height)\"\n        }\n    }\n    ```\n\n    ```swift\n    class Size {\n        var width: Int = 10\n        var height: Int = 10\n        var x: Int = 0\n        var y: Int = 0\n\n        func adjustSize(newWidth: Int, newHeight: Int) {\n            width = newWidth\n            height = newHeight\n            print(\"Size adjusted to \\(width) x \\(height)\")\n        }\n    }\n\n    let mySize = Size()\n\n    mySize.adustSize(newWidth: 20, newHeight: 20)\n    ```\n\n## Inheritance\n\n```swift\nclass Shape {\n    var color: String\n\n    init(color: String) {\n        self.color = color\n    }\n\n    func draw() {\n        print(\"Drawing a shape in \\(color) color.\")\n    }\n}\n\nclass Circle: Shape {\n    var radius: Double\n\n    init(color: String, radius: Double) {\n        self.radius = radius\n        super.init(color: color)\n    }\n\n    override func draw() {\n        print(\"Drawing a circle with radius \\(radius) in \\(color) color.\")\n    }\n}\n\nclass Square: Shape {\n    var width: Double\n    var height: Double\n\n    init(color: String, width: Double, height: Double) {\n        self.width = width\n        self.height = height\n        super.init(color: color)\n    }\n\n    override func draw() {\n        print(\"Drawing a rectangle with width \\(width) and height \\(height) in \\(color) color.\")\n    }\n}\n\nlet redCircle = Circle(color: \"Red\", radius: 5.0)\nlet blueSquare = Square(color: \"Blue\", width: 8.0, height: 6.0)\n\nredCircle.draw()\nblueSquare.draw()\n\n// dynamic dispatch\nvar circleShape: Shape = Circle(color: \"Red\", radius: 5.0)\ncircleShape.draw()\n```\n\n## designated / convenience initializer\n\nPrinciple:\n\n1. A designated initializer must call a designated initializer from its immediate superclass.\n2. A convenience initializer must call another initializer from the same class.\n3. A convenience initializer must ultimately call a designated initializer.\n\nRemember:\n\n- Designated initializers must always delegate up.\n\n- Convenience initializers must always delegate across.\n\n```swift\nclass Car {\n    var brand: String\n    var model: String\n    // designated initializer\n    init(brand: String, model: String) {\n        self.brand = brand\n        self.model = model\n    }\n}\n\nclass ElectricCar: Car {\n    var batteryCapacity: Double\n\n    // Designated initializer, must call parent designated initializer\n    init(brand: String, model: String, batteryCapacity: Double) {\n        self.batteryCapacity = batteryCapacity\n        super.init(brand: brand, model: model)\n    }\n\n    // Convenience initializer, must call current class defined designated initializer\n    convenience override init(brand: String, model: String) {\n        // default battery capacity set to 60\n        self.init(brand: brand, model: model, batteryCapacity: 60.0)\n    }\n}\n\nlet teslaModel3 = ElectricCar(brand: \"Tesla\", model: \"Model 3\", batteryCapacity: 75.0)\nlet nissanLeaf = ElectricCar(brand: \"Nissan\", model: \"Leaf\")\n```\n\n- concept:\n\n1. 想要父類別的`convenience initializer`，我們需要`override`父類別的所有`designated initializer`","n":0.036}}},{"i":64,"$":{"0":{"v":"Serialization","n":1},"1":{"v":"\n**Foundation** library定義了`Encodable`, `Decodable`, 也提供`Encoder`, `Decoder` API讓我們可以很方便地進行資料處理。\n\n當我們需要更深入的設定時，也可以使用`EncodableWithConfiguration`, `DecodableWithConfiguration`這兩個protocols。\n\n## 為何我們需要將資料encode、decode呢？\n\n當我們透過網路傳送資料、將資料存到硬碟上，通常都需要先將檔案編碼成特定的格式再做傳輸、儲存。\n\n而我們在撰寫程式碼時，會定義出一些類(class、struct)，當我們需要將這些類別的實體拿來做傳輸、儲存時，我們必須要讓這個類`Codable`，才可以透過Decoder、Encoder處理我們的資料。\n\n## `Codable` Behind the scenes\n\n![codable behind the scenes](/assets/images/programming.language.swift.Serialization_behind-the-scenes.png)\n\n## Example\n\n```swift\nstruct TestEncode {\n    let id: String\n    let intArr: [Int] = [1,2,3,4,5]\n}\n\n// Instance method 'encode' requires that 'TestEncode' conform to 'Encodable'\nlet encodedJSONData = try? JSONEncoder().encode(TestEncode(id: \"encode&decode\"))\nlet encodedPropertyListData = try? PropertyListEncoder().encode(TestEncode(id: \"encode&Decode\"))\n```\n\n如果自定義的類沒有遵守`Encodable` protocol，encoder的encode方法是沒有辦法接收自定義類的實例的。\n\n這時候只需要讓TestEncode遵守`Encodable`，即可順利encode了\n\n```swift\nstruct TestEncode: Encodable {\n    let id: String\n    let intArr: [Int] = [1,2,3,4,5]\n}\n```\n\n## Foundation codable types\n\n- String\n- Int\n- Double\n- Date\n- Data\n- URL\n\n## 自定義 `CodingKeys`\n\n當自定義的類遵守`Codable`時，我們可以選擇在類別內宣告一個叫`CodingKeys`的enum，且這個enum需遵守`CodingKey`協議。\n\n```swift\n/// A type that can be used as a key for encoding and decoding.\npublic protocol CodingKey : CustomDebugStringConvertible, CustomStringConvertible, Sendable {\n\n    /// The string to use in a named collection (e.g. a string-keyed dictionary).\n    var stringValue: String { get }\n\n    init?(stringValue: String)\n\n    /// The value to use in an integer-indexed collection (e.g. an int-keyed dictionary).\n    var intValue: Int? { get }\n\n    init?(intValue: Int)\n}\n\nextension CodingKey {\n    /// A textual representation of this key.\n    public var description: String { get }\n\n    /// A textual representation of this key, suitable for debugging.\n    public var debugDescription: String { get }\n}\n```\n\n### Why?\n\n有時候序列化後的資料格式(key-value pair)的key命名並不符合Swift的命名邏輯，且有時候這個key會頻繁被更改，與其隨著這些外部的資料key去做property的命名，不如就透過宣告`CodingKeys`拿來map這些外部的資料格式。\n\n```swift\nlet mockJSONData = \"\"\"\n    {\n      5\"first_name\": \"Jason\",\n      \"last_name\": \"Chung\"\n    }\n\"\"\"\n\nstruct User: Codable {\n    let firstName: String\n    let lastName: String\n\n    enum CodingKeys: String, CodingKey {\n      case firstName = \"first_name\"\n      case lastName = \"last_name\"\n    }\n}\n\nlet encodedJSONData = try! mockJSONData.data(using: .utf8)!\nlet decodedJSONData = try JSONDecoder().decode(User.self, from: encodedJSONData)\n```\n\n## `Codable`常用的情境：\n\n1. JSON Serialization/Deserialization\n2. PropertyList Serialization\n3. UserDefaults\n4. Unit Testing (透過自定義類建立假資料，轉換成JSON格式測試Decoding出錯情境)","n":0.068}}},{"i":65,"$":{"0":{"v":"Decoding JSON","n":0.707}}},{"i":66,"$":{"0":{"v":"Nested Data","n":0.707},"1":{"v":"\n## 前情提要\n\n今天的需求是，前端的資料流以及畫面渲然只需要部分的資料，但是後端訂出的API格式多給了很多暫時不需要的資料。\n\n## 資料處理步驟\n\n### Step1 先釐清前端所需要的資料結構\n\n於是我們考量了`GroceryStore`跟`Product`之間的關聯性，我們定義出了下方的類:\n\n```swift\n// 每間商店包含 商店名、商品陣列\nstruct GroceryStore {\n    var name: String\n    var products: [Product]\n\n    struct Product: Codable {\n        var name: String\n        var points: Int\n        var description: String?\n    }\n}\n```\n\n### Step2 建立一個中繼的類去Decode我們拿回來的資料\n\n但是今天API定出來的資料格式如下：\n\n```json\n[\n    {\n        \"name\": \"Home Town Market\",\n        \"aisles\": [\n            {\n                \"name\": \"Produce\",\n                \"shelves\": [\n                    {\n                        \"name\": \"Discount Produce\",\n                        \"product\": {\n                            \"name\": \"Banana\",\n                            \"points\": 200,\n                            \"description\": \"A banana that's perfectly ripe.\"\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n    {\n        \"name\": \"Big City Market\",\n        \"aisles\": [\n            {\n                \"name\": \"Sale Aisle\",\n                \"shelves\": [\n                    {\n                        \"name\": \"Seasonal Sale\",\n                        \"product\": {\n                            \"name\": \"Chestnuts\",\n                            \"points\": 700,\n                            \"description\": \"Chestnuts that were roasted over an open fire.\"\n                        }\n                    },\n                    {\n                        \"name\": \"Last Season's Clearance\",\n                        \"product\": {\n                            \"name\": \"Pumpkin Seeds\",\n                            \"points\": 400,\n                            \"description\": \"Seeds harvested from a pumpkin.\"\n                        }\n                    }\n                ]\n            }\n        ]\n    }\n]\n```\n\n於是我們建立了一個中繼的類，去接收傳過來的資料。\n\n```swift\nstruct GroceryStoreService {\n    let name: String\n    let aisles: [Aisles]\n\n    struct Aisles: Decodable {\n        let name: String\n        let shelves: [Shelves]\n\n        struct Shelves: Decodable {\n            let name: String\n            let product: GroceryStore.Product\n        }\n    }\n}\n```\n\n### Step3 把Step1建立的類透過`extension`讓我們可以透過中繼類初始化我們真正需要的資料\n\n```swift\nextension GroceryStore {\n    init(from service: GroceryDataService) {\n        name = service.name\n\n        products = []\n        for aisle in service.aisles {\n            for shelf in service.shelves {\n                product.append(shelf.product)\n            }\n        }\n    }\n}\n```","n":0.074}}},{"i":67,"$":{"0":{"v":"Merge Data","n":0.707},"1":{"v":"\n## 前情提要\n\n很多時候前端定義出的model跟資料來源有點出入，例如：\n\n我們定義的Model:\n\n```swift\nstruct Team: Codable {\n    var members: [Member]\n    let id: String\n\n    struct Member: Codable {\n      let name: String\n      let id: String\n      let age: Int\n    }\n}\n```\n\n預期進來的資料是 ⇩\n\n```json\n{\n    \"members\": [\n        {\n            \"name\": \"Jason\",\n            \"id\": \"123\",\n            \"age\": 20\n        },\n        {\n            \"name\": \"Lyy\",\n            \"id\": \"456\",\n            \"age\": 18\n        }\n    ]\n}\n```\n\n但是實際資料是 ⇩，這時候我們就會需要針對key去做特別的處理。\n\n```json\n// 實際的 JSON Data\n{\n    \"members\": [\n        \"Jason\": {\n            \"id\": \"123\",\n            \"age\": 20\n        },\n        \"Lyy\": {\n            \"id\": \"456\",\n            \"age\": 18\n        }\n    ]\n}\n```\n\n這個時候我們不應該為了Decode而再建立一個新的類別，專門去迎合資料的結構，而是加工處理進來的資料，讓他符合我們App開發的商業邏輯。\n\n## 資料處理步驟\n\n```swift\nextension Team {\n    struct MemberKey: CodingKey {\n        var stringValue: String\n\n        init?(stringValue: String) {\n          self.stringValue = stringValue\n        }\n\n        var intValue: Int?\n\n        init?(intValue: Int) {\n          return nil\n        }\n\n        static let id = MemberKey(stringValue: \"id\")!\n        static let age = MemberKey(stringValue: \"age\")!\n    }\n\n    enum CodingKeys: CodingKey {\n        case members\n        case id\n    }\n\n    func encode(to encoder: Encoder) throws {\n        var container = encoder.container(keyedBy: CodingKeys.self)\n\n        try container.encode(id, forKey: .id)\n        var memberContainer = container.nestedContainer(keyedBy: MemberKey.self, forKey: .members)\n\n        for member in members {\n            let nameKey = MemberKey(stringValue: member.name)!\n\n            var nestedContainer = memberContainer.nestedContainer(keyedBy: MemberKey.self, forKey: nameKey)\n            try nestedContainer.encode(member.id, forKey: .id)\n            try nestedContainer.encode(member.age, forKey: .age)\n        }\n    }\n\n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        let memberContainer = try container.nestedContainer(keyedBy: MemberKey.self, forKey: .members)\n        id = try container.decode(String.self, forKey: .id)\n\n        members = []\n        for key in memberContainer.allKeys {\n            let memberContainer = try memberContainer.nestedContainer(keyedBy: MemberKey.self, forKey: key)\n            let age = try memberContainer.decode(Int.self, forKey: .age)\n            let id = try memberContainer.decode(String.self, forKey: .id)\n\n            members.append(Member(name: key.stringValue, id: id, age: age))\n      }\n    }\n}\n```","n":0.067}}},{"i":68,"$":{"0":{"v":"Git Flow","n":0.707},"1":{"v":"\n```mermaid\n    gitGraph\n       commit id: \"init\"\n       branch release\n       branch develop\n       branch be_feature1\n       branch be_feature2\n       branch fe_feature1\n       branch fe_feature2\n       checkout be_feature1\n       commit\n       commit\n       commit\n       checkout be_feature2\n       commit\n       commit\n       commit\n       checkout fe_feature1\n       commit\n       commit\n       checkout fe_feature2\n       commit\n       commit\n       checkout develop\n       merge be_feature1\n       merge be_feature2\n       merge fe_feature1\n       merge fe_feature2\n       checkout release\n       merge develop\n       checkout main\n       merge release\n```\n\n```git\n[type] title\nbody\nfooter\n```","n":0.136}}},{"i":69,"$":{"0":{"v":"Design Pattern","n":0.707}}},{"i":70,"$":{"0":{"v":"Factory","n":1},"1":{"v":"\n## Factory Pattern 如何隱藏複雜性？\n\n將特定物件複雜的初始化程序，封裝到一個factory class，當我們需要特定物件就從這個factory class取得。\n\n假設將建立彈跳視窗物件的code封裝到一個class(factory)，當我們app有view需要用到彈窗時，僅需要透過這個factory製造出我們想要的彈窗。\n\n## How to implement Factory Pattern?\n\n以彈跳視窗為例：\n\n1. 建立一個interface(protocol)，每個彈窗都需要可以\n   1. 點擊關閉\n   2. 點擊確認\n\n2. 建立Factory class","n":0.236}}},{"i":71,"$":{"0":{"v":"POP","n":1},"1":{"v":"\n## What POP differs from OOP\n\n- Classes can only inherit from one other class while protocols can inherit from multiple protocols.\n- Large hierarchies can easily pollute subclasses with too many extra features.\n\n## POP + Value Semantic = Performance & Local Reasoning","n":0.156}}},{"i":72,"$":{"0":{"v":"OOP","n":1},"1":{"v":"\n## Languages\n\n- Python\n- C#\n- Java\n- Ruby\n\n## Pillars\n\n```mermaid\nflowchart TD\n  A[OOP Pillars] --> B[Inheritance]\n  A --> C[Polymorphism]\n  A --> D[Encapsulation]\n  A --> E[Abstraction]\n```\n\n1. Inheritance:\n   1. code reusability\n2. Polymorphism\n   1. overriding methods in child classes\n3. Encapsulation\n   1. hide private interface, show with public\n   2. access control\n4. Abstraction\n\n## Building blocks\n\n- Classes\n- Objects\n- Methods\n- Attributes","n":0.141}}},{"i":73,"$":{"0":{"v":"Network","n":1}}},{"i":74,"$":{"0":{"v":"WebRTC","n":1},"1":{"v":"\n## 實現WebRTC的步驟\n\n1. Signalling\n\n開啟直播的Peer需要提供一個offer，裡面包含SDP(session description protocol)，會寫在signal server，才能讓另一位的peer回應這個SDP。\n\n需要交換的資訊：\n- IP Address\n- audio + video tracks\n- data channels that determine the media type with a resolution exchange\n\n2. Connecting\n\nPeer彼此之間需要產生一個list的ICE(IP/port pair)，才能讓WebRTC透過STUN Server連接。\n每個Peer一樣要將他們的ICE寫入firestore，才能讓其他peer讀到。\n\n- ICE: Interactive connectivity establishment (uses STUN/TURN servers)\n  - **STUN** Standard Traversal Utilities for NAT\n    - 幫忙取得網路IP -> 透過發送Stun server請求\n  - **TURN** Traversal Using Relays around NAT\n    - 幫忙處理裝置之間因為防火牆而中斷連線的server\n    - These servers are used to work up with the privacy of the agents by not letting the servers locate the IP of the communicators. TURN creates a temporary IP for the agents to generate traffic to and fro, acting as a proxy.\n\n3. Securing\n\n- DTLS(Datagram Transport Layer Security)\n  - allows webRTC to establish a secured and encrypted communication between two peers. The client and the server to communicate, need a agree on certain values known as ciphers in a DTLS handshake. To secure the data streams of the peers, DTLS is required\n- SRTP(Secure Real-time Transport Protocol)\n  - It secures and encrypts the media streams between two connecting peers. It is initialized by using keys generated by DTLS. This protocol is specifically designed for encrypting RTP packets.","n":0.075}}},{"i":75,"$":{"0":{"v":"Web Socket","n":0.707},"1":{"v":"\n## What is Socket.IO\n\n一個函式庫，用途在於實現Server跟Client的溝通\n\n- 一個整合node.js http Server的套件 (socket.io)\n- 封裝客戶端http\n\n## Why Socket.IO?\n\n1. 低延遲\n2. 雙向\n3. event base\n\n## How to use Socket.IO?\n\n- Server:\n  1. 引入套件封裝好的 **Server** class\n  2. 將node:http建立出來的**HTTP server**物件當參數來初始化 socket 的 **Server** class\n\n      ```js\n      import express from 'express';\n      import { createServer} from 'node:http';\n      import { Server } from 'socket.io';\n\n      const app = express();\n      const server = createServer(app);\n      const io = new Server(server)\n      ```\n\n  3. 透過這樣子產生出來的io實體，可以透過`on` method開啟socket通道\n\n      ```js\n      io.emit('hello','world') // 提交給所有connected的sockets\n\n      io.on('connection', (socket) => {\n        socket.broadcast.emit('hi');\n      })\n      ```\n\n  4. 後端透過emit傳送訊息給前端\n\n- Client:\n  1. 前端會需要一個io實例\n  2. 透過io實例的emit提交客戶端訊息\n\n## Remember\n\n1. 前端的socket不會永遠都連線中\n2. server端的socket不會存任何事件\n","n":0.108}}},{"i":76,"$":{"0":{"v":"Libraries","n":1}}},{"i":77,"$":{"0":{"v":"Alamofire","n":1},"1":{"v":"\n## What is it built for?\n\nProvide elegant and composable interface to HTTP network requests.\n\n## How it was built\n\nBuilt on top of Apple's `URL Loading System` provided by `Foundation` framework\n\nWrapping up `URLSession` and the `URLSessionTask` subclasses.\n\n### Where does `AF` come from?\n\n```swift\n// Shared singleton instance used by all `AF.request` APIs. Cannot be modified.\n// Session可以建立、管理Request實例。\npublic let AF = Session.default\n```\n\n#### `Session`職責\n\n建立Request\n\n#### `URLConvertible`、`URLRequestConvertible`protocol\n\n```swift\npublic protocol URLConvertible {\n    /// Returns a `URL` from the conforming instance or throws.\n    ///\n    /// - Returns: The `URL` created from the instance.\n    /// - Throws:  Any error thrown while creating the `URL`.\n    func asURL() throws -> URL\n}\n\npublic protocol URLRequestConvertible {\n    /// Returns a `URLRequest` or throws if an `Error` was encountered.\n    ///\n    /// - Returns: A `URLRequest`.\n    /// - Throws:  Any error thrown while constructing the `URLRequest`.\n    func asURLRequest() throws -> URLRequest\n}\n```\n\n\n\n### `SessionDelegate` 職責\n\n> Class which implements the various `URLSessionDelegate` methods to connect various Alamofire features.\n\n- URLSessionDelegate\n- URLSessionTaskDelegate\n- URLSessionDataDelegate\n- URLSessionWebSocketDelegate\n- URLSessionDownloadDelegate\n\n## Usage\n\n### requests\n\n","n":0.081}}},{"i":78,"$":{"0":{"v":"Resume","n":1}}},{"i":79,"$":{"0":{"v":"Self Intro","n":0.707},"1":{"v":"\n## **Summary**\n\nTransitioned from a financial background into software development.\nExperienced in iOS application and web development.\nI am enthusiastic about the evolving tech landscape, always prepared to contribute and learn.\n\n## **Tech Stack**\n\n- Languages: Swift, JavaScript\n- iOS related: SwiftUI, Combine, Core Data, AVFoundation, MapKit, CoreML, Vision\n- Concepts: ARC, Concurrency, OOP, POP, MVVM, Unit Testing\n- Libraries: Alamofire, SwiftLint, Kingfisher, MessageKit\n- Networking: RESTful APIs, WebSocket, WebRTC\n- CI / CD: Xcode Cloud\n- Tools: SourceTree, Postman, Git / GitHub, CocoaPods, Dendron\n\n## **Projects**\n\n### Flavor Flash\n\n> A culinary explorer hub for foodies, sharing meals by photo or live stream.\n\n- Developed with SwiftUI, implementing the MVVM architecture coupled with Combine for enhanced flexibility and maintainability.\n\n- Designed flexible custom UI components, incorporating a comprehensive style guide through ViewModifiers to ensure a unified and flexible app interface.\n- Bridged UIKit components(UIView / UIViewController) into SwiftUI views.\n- Capturing and Previewing both food and facial images simultaneously using user’s front and back cameras, utilizing AVFoundation's API to proficiently manipulate the user's device camera.\n- Implemented live streaming food sharing functionality using WebRTC, with Cloud Firestore serving as the signaling client for communication.\n- Analyzed food images by category via CoreML + Vision, using a self-trained model created with CreateML for enhanced accuracy and customization.\n- Search nearby restaurants by fetching data provided by Google Places API, and then render fetched geographic data via MapKit.\n- Implemented chat functionality by actively observing Cloud Firestore collection for real-time communication.\n- Managed concurrent code effectively by leveraging Swift's new language features, which involved encapsulating SDK completionHandler closures within asynchronous functions.\n\n### STYLiSH\n\n> An E-Commerce app, allowing users to browse through clothing and accessories.\n\n- Developed with UIKit, meeting the UI / UX specifications outlined in Figma.\n- Built Interface using a combination of storyboards and programmatic approaches, adapting the concept of auto layout.\n- Implemented communication between UIViewControllers and Managers via delegates and closures.\n- Implemented Core Data as the local data persistence store for shopping cart functionality.\n- Integrated Facebook and TapPay SDK into the application for login and checkout functionality.\n- Implemented a customer service chat feature via WebSocket during a co-work session with back-end engineers.\n- Performing network requests using both Alamofire and URLSession, demonstrating versatility in managing API communications through widely adopted libraries and native iOS frameworks.\n\n## **Work Experiences**\n\n### iOS Engineer, AppWorks School, Sep 2023 - Jan 2024\n\n- Developed \"Flavor Flash\" personal project. Quickly picked up SwiftUI within 5 weeks, showcasing my adaptability to new technologies.\n- Developed \"STYLiSH\" E-Commerce project using UIKit, meeting the specifications outlined in Figma.\n- Collaborated seamlessly with web front-end and back-end engineers and integrated customer service chat functionality into the \"STYLiSH\" e-commerce app, securing second place in the co-working competition.\n\n### Front-End Engineer, Wisdom Courage, May 2023 - Aug 2023\n\n- Developed Content Management System front-end interfaces, collaborating with back-end engineers to integrate API endpoints.\n- Resolved bug tickets on Redmine, demonstrating proficiency in issue resolution and ensuring project quality.\n- Enhanced existing projects by incorporating new features as per the product manager's requirements.\n\n### Auditor, Deloitte, Oct 2021 - Sep 2022\n\n- Collaborated with a team of auditors to review and analyze Cathay United Bank's financial statements for Q3 and Q4 2021, along with Q1 and Q2 2022.\n- Completed worksheets assigned by supervisors, and proactive follow-up with clients to obtain financial information.\n\n## **Education**\n\n### National Sun Yat-Sen University\n\n#### Bachelor's degree in Finance\n\n- Acted as the department representative for a duration of one year.\n- Assumed the role of the breaking instructional leader for the Power Dance Club for one year.","n":0.042}}}]}
