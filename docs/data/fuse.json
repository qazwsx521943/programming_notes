{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"root","n":1},"1":{"v":"\nThis is the root for your Dendron vault.\n\nIf you decide to publish your entire vault, it will be your landing page. You are free to customize any part of this page except the frontmatter at the top, between the `---`.\n","n":0.158}}},{"i":2,"$":{"0":{"v":"Tutorial","n":1},"1":{"v":"\nWelcome to Dendron! Dendron is a developer-focused knowledge base that helps you manage information using **flexible hierarchies**!\n\nYou are currently in the tutorial vault (a vault is the folder where your notes are stored). Feel free to edit this note and create new files as you go through the quickstart!\n\n## Create a Note\n\n1. Use `Ctrl+L` / `Cmd+L` to bring up the lookup prompt\n1. Type `dendron` and select `Create New`\n\n- > NOTE: After you press enter, Dendron will create and open the `dendron` note. Use `<CTRL>-<TAB>` to come back to this note\n\nYou just created your first note!\n\n- > NOTE: Notes in Dendron are just plain text markdown with some [frontmatter](https://wiki.dendron.so/notes/ffec2853-c0e0-4165-a368-339db12c8e4b) on the top. You can edit them in Dendron or using ~~vim~~ your favourite text editor.\n\n## Find a Note\n\n1. Use `Ctrl+L` / `Cmd+L` to bring up the lookup prompt again\n1. Type `dendron` and press `<ENTER>`\n\n- > TIP: you don't have to type out the entire query, press `<TAB>` to autocomplete\n\nYou just `looked up` a note!\n\n- > NOTE: in Dendron, you can find or create notes using the lookup prompt\n\n## Organize your Notes\n\n1. Bring up the lookup prompt again\n1. Type `tutorial.one`\n\nYou just created your first hierarchy!\n\n- > NOTE: hierarchies in Dendron are just `.` delimited files. This makes each note both a file and a folder and makes it easy to keep your notes organized\n\n- > TIP: You can use the [Dendron Tree View](https://wiki.dendron.so/notes/hur7r6gr3kqa56s2vme986j) to view your hierarchy. If it's not currently in focus, you can use `CTRL+SHIFT+P`/`CMD+SHIFT+P` to open the command prompt and type in `Dendron: focus on tree view` to make it appear\n\n## Create a link\n\n1. In the current note, type `[[` - this should trigger the autocomplete. You can type `one` to narrow it down to the note you just created and hit enter\n<!-- Enter '[[' below-->\n\n<!-- End space-->\n\nYou just created your first link!\n\n- > NOTE: the links with the `[[` are called wikilinks (because they were first popularized by Wikipedia)\n- > TIP: If you hover your mouse over the link, you can get a preview of the contents inside the note!\n\n## Navigate a link\n\n1. Move your text cursor over the link you just created. Hold down `<CTRL>+<ENTER>`/`<CMD>+<ENTER>`\n\n- > TIP: You can also use `CTRL+CLICK` or `CMD+CLICK` to navigate links via mouse\n\nYou just navigated the link!\n\n## Refactor a Note\n\n1. Open [[tutorial.one]], bring up the command prompt (`CTRL+SHIFT+P`/`CMD+SHIFT+P`) and type `Dendron: Rename Note`\n1. Replace `tutorial` with `my-note` and then press `<ENTER>`\n1. You just refactored the note!\n\n- > NOTE: when you rename a note, Dendron updates all links and references of the original note being renamed. Try switching back to [[tutorial]] to see the updated link!\n- > TIP: in addition to renaming one note at a time, dendron has [an entire collection](https://wiki.dendron.so/notes/srajljj10V2dl19nCSFiC) of refactoring commands that let you change headers, move around sections, and refactor entire hierarchies!\n\n## Conclusion\n\nCongrats, you finished the Dendron tutorial!\n\nWas there anything **unclear or buggy** about this tutorial? Please [**report it**](https://github.com/dendronhq/dendron/discussions/3266) so we can **make it better**!\n\n## Next Steps\n\nDepending on your needs, here are some common next steps:\n\n- I want to **start writing**: [Create a daily journal note](command:dendron.createDailyJournalNote) ([docs](https://wiki.dendron.so/notes/ogIUqY5VDCJP28G3cAJhd))\n\n- I want to **use templates**: Use the [Appy Template](https://wiki.dendron.so/notes/ftohqknticu6bw4cfmzskq6) command to apply [templates](https://wiki.dendron.so/notes/861cbdf8-102e-4633-9933-1f3d74df53d2) to existing notes\n\n- I want to do a **longer tutorial**: Check out our [5min tutorial to explore more of Dendron's functionality](https://wiki.dendron.so/notes/678c77d9-ef2c-4537-97b5-64556d6337f1/)\n\n- I want to **implement a particular workflow** (bullet journal, zettelkasten, etc): Check out community [workflow guides](https://wiki.dendron.so/notes/9313b845-d9bf-42c9-aad1-0da34794ce26)\n\n- I want to use Dendron for **tasks and todos**: See the [Getting Things Done (GTD), Bullet Journaling, and Other Task Management Workflows](https://wiki.dendron.so/notes/ordz7r99w1v099v14hrwgnp) for how the founder of Dendron uses it to manage his work.\n\n- I want to explore **advanced features**: See [next steps](https://wiki.dendron.so/notes/TflY5kn29HOLpp1pWT9tP) for longer walkthroughs and advanced functionality!\n\n- I want to start clean with a **new vault at a custom location**: Run [Dendron: Initialize Workspace](command:dendron.initWS) from the command prompt (or click this link) to start from a clean slate\n\n- I want to use Dendron as a **knowledge base for my team**: Read the [Dendron team setup](https://wiki.dendron.so/notes/98f6d928-3f61-49fb-9c9e-70c27d25f838) to get started\n\n> Coming from Obsidian? Click [here](command:dendron.importObsidianPod) to import your Obsidian notes (or any markdown notes) into Dendron to see how they look.\n\n## Community\n\nDendron is more that just a tool - we are also a community of individuals that are passionate about knowledge management. If you need help or want to connect with the community, join us in the [Discords](https://link.dendron.so/discord).\n\nYou can also:\n\n- Star us on [GitHub](https://github.com/dendronhq/dendron)\n- Follow us on [Twitter](https://twitter.com/dendronhq)\n- Subscribe to the [Dendron Newsletter](https://link.dendron.so/newsletter)\n","n":0.037}}},{"i":3,"$":{"0":{"v":"Programming","n":1}}},{"i":4,"$":{"0":{"v":"Side Projects","n":0.707}}},{"i":5,"$":{"0":{"v":"Flavor Flash Journal","n":0.577},"1":{"v":"\nFlavor Flash 開發筆記\n\n## Food App\n\n- TA:\n\n  1. 喜歡被動探索美食的人\n  2. 有選擇障礙 / 不想花時間想要吃什麼的人\n  3. 喜歡紀錄食物口感的人\n  4. google評論有時候可以被刷出來、不如朋友圈一起建立可信的美食地圖\n\n- Feature:\n\n  1. 隨機選食物 -> 找附近的餐廳\n  2. 左滑右滑收藏餐廳 (餐廳抽卡,UI要炫砲)\n  3. 美食日記\n     1. 飢餓狀態\n     2. 上傳圖片，\n        1. 後鏡頭拍食物分析食物的標籤(分析不準也可帶入自定義標籤)\n        2. 前鏡頭拍人像分析人臉（喜怒哀樂）作為評價\n     3. 寫下心得\n  4. 可以查看自己曾到訪的餐廳，針對吃的次數給不同顏色圖釘、註解\n  5. 好友的頁面可以查看他的美食日記、以及他的美食地圖(曾到訪的餐廳)\n  6. 聊天系統\n     1. 1對1\n     2. 群組\n     3. 傳jpg、png、gif\n     4. 分享餐廳資訊\n     5. (optional)影片\n     6. (optional)投票要吃的餐廳\n  7. 成就勳章：（月結、週結、小任務）\n     1. 很常吃飯 => 飯桶\n     2. 常常不同的餐廳 => 發現新大陸\n  8. 週飲食習慣、月飲食習慣分析(3D呈現)\n  9. APP顏色要可切換\n  10. 日曆簽到系統，當天有發美食日記的話就算簽到成功\n  11. 動態島、鎖屏提示(Activity Kit)\n\n- 預計需要學的東西:\n  1. MapKit\n     1. Marker & Annotation\n     2. selection\n     3. contentBuilder\n     4. mapStyle\n  2. SpriteKit\n  3. AVFoundation\n  4. CoreML\n     1. Vision\n  5. Firebase APIs\n\n\n- reference:\n  1. https://github.com/PCChuang/Subminder\n  2. https://github.com/TaiHsin/Travel\n  3. https://github.com/pisck888/Hahabbit\n  4. https://github.com/thisisalliet/FocusFoodie\n\n\n![](/assets/images/ifoodie-webconfig.png)\n\n我這次個人專案開發的是一款探索及紀錄美食的app，那會想要開發這款app的原因是因為我每天都會遇到午餐晚餐要吃什麼的問題，再加上女朋友有紀錄以及分享美食的習慣，於是我就決定以這兩個需求去開發這款美食App。\n\n首先，首頁放的是我自己最常使用的功能，那我的使用情境就是在每天中午不知道要吃什麼時候就可以打開來點一下，並且透過調整地圖參數去調整你想看到的餐廳搜尋結果。\n\n那進到地圖搜尋的頁面時，使用者可以透過點擊圖釘以及下方的餐廳卡片去移動到該餐廳的位置，點擊下方卡片也可以看到餐廳的基本資料。\n\n如果我在瀏覽餐廳的時候看到了幾間還不錯的餐廳，我也可以餐廳資訊這邊先加到我的待吃清單，等到下一餐又不知道要吃什麼的時候，也可以從待吃的清單去做選擇。\n\n那如果在地圖上有看到這餐想吃的餐廳時，你就可以點擊該餐廳的圖釘然後點旁邊的地圖icon去開啟apple map的導航。\n\n那回到首頁點擊收藏的ICON就可以看到你待吃名單中的餐廳有哪些，如果吃了就可以把該餐廳移除待吃名單。\n\n那這是探索附近餐廳的功能，接下來要帶過的是記錄美食的功能，使用者可以點擊這個相機的icon開啟前後鏡頭，開啟後使用者可以對鏡頭的顯示做一些調整，查看有沒有死角。\n\n拍好之後也可以再次確認照片沒有問題，做一些簡單的編輯，那如果沒有問題就可以進一步寫下心得。\n\n發文美食評論之後就可在美食足跡的社群中，看到自己跟朋友的發文，你可以對貼文留言&按讚。那如果有一些私底下想詢問的美食問題，也可以去聊天室建立群組聊天。\n\n那除了在這個社群頁面可以看到其他朋友的發文，使用者也可以在個人頁面的foodprint中在地圖上查看他過往吃過的餐廳，也可以跟朋友做足跡的疊加。\n","n":0.097}}},{"i":6,"$":{"0":{"v":"Xcode Issues","n":0.707},"1":{"v":"\n## SPM can't find module\n\n```git\nrm -rf ~/Library/Developer/Xcode/DerivedData\n```\n\n## Fastest Way removing Derived Data\n\n```terminal\nrm -rf ~/Library/Developer/Xcode/DerivedData\n```\n\n## Multiple command produce\n\nhttps://stackoverflow.com/questions/50718018/xcode-10-error-multiple-commands-produce\n\n## Check Thread issue\n\n![](/assets/images/project%20brainstorming.flavor%20flash%20journal.xcode%20issues_check_thread.png)\n\n## XCode project file merge 'group'\n\n要注意合併時，檔案夾之間是否有 source group結尾包住，否則會有啟動不了的問題\n\n```\nE7FFB38B2B1CA2B90065A213 /* FoodPrintHistoryViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FoodPrintHistoryViewModel.swift; sourceTree = \"<group>\"; };\n```\n\n## 如何查看模擬器的UserDefaults plist?\n\nhttps://pradnya-nikam.medium.com/view-and-change-user-defaults-on-ios-simulator-d2c3fc3b82b1\n\n1. 先找到模擬器被存在哪：\n    ```\n    /Users/zhongzhexuan/Library/Developer/CoreSimulator/Devices/BE1B25CF-FBF9-4850-BBCC-58807BA3D19B\n    ```\n2. 進到模擬器的資料夾：\n    ```\n    find . -name ios22-jason.SwiftJunior.plist\n    ```\n3. 如果有UserDefaults檔案，就會搜尋的到\n    ```\n    ./data/Containers/Data/Application/521CEC9B-FB38-4A6B-8329-02CC51188A20/Library/Preferences/ios22-jason.SwiftJunior.plist\n    ```","n":0.128}}},{"i":7,"$":{"0":{"v":"Test","n":1},"1":{"v":"\nIn Xcode, we have to kind of automated test we can write.\n\nXCTest Framework is the framework that helps us write **unit** / **ui** test\n\nTest跟Refactor是相輔相成的，\n如果可以在Refactor之前把Test Code寫好，那你就可以拿來驗證你Refactor後的Code是否也可以正常運作。\n\nXCode中做單元測試的方法：\n\nTesting Class必須繼承XCTestCase，且這個class中的function都必須以test prefix.\n\n最常使用的斷言物件就是`XCTAssertEqual`去測試結果是否符合預期。","n":0.192}}},{"i":8,"$":{"0":{"v":"Unit Test","n":0.707}}},{"i":9,"$":{"0":{"v":"UI Test","n":0.707},"1":{"v":"\n## Goal\n\n確保所有UI物件存在View上","n":0.707}}},{"i":10,"$":{"0":{"v":"Style Guide","n":0.707}}},{"i":11,"$":{"0":{"v":"Custom Styling","n":0.707},"1":{"v":"\n## ButtonStyle, ToggleStyle, etc\n\nThey have a method creates the view.\n\n```swift\nfunc makeBody(configuration: Self.Configuration) -> some View\n```","n":0.258}}},{"i":12,"$":{"0":{"v":"Mapkit","n":1},"1":{"v":"\n## iOS 16.0 (interfacing with UIKit)\n\n當某個struct conform `UIViewRepresentable`\n需要實作 `makeUIView`, `updateUIView` protocol function\n\n### Callback Order\n\n1. makeCoordinator\n   1. Creates the custom instance that you use to communicate changes(by delegates) from your view to other parts of your SwiftUI interface.\n\n    ```swift\n    associatedtype Coordinator = Void\n\n    @MainActor func makeCoordinator() -> Self.Coordinator\n    ```\n\n2. makeUIView\n   1. Creates the view object and configures its initial state.\n\n    ```swift\n    /// You must implement this method and use it to create your view object.\n    /// Configure the view using your app's current data and contents of the\n    /// `context` parameter. The system calls this method only once, when it\n    /// creates your view for the first time. For all subsequent updates, the\n    /// system calls the ``UIViewRepresentable/updateUIView(_:context:)``\n    /// method.\n\n    associatedtype UIViewType : UIView\n\n    func makeUIView(context: Self.Context) -> Self.UIViewType\n    ```\n\n3. updateUIView\n   1. Updates the state of the specified view with new information from SwiftUI.\n   2. When properties like `@Published` changed, calls this method to update portions of your interface affected by those changes.\n\n    ```swift\n    /// When the state of your app changes, SwiftUI updates the portions of your\n    /// interface affected by those changes. SwiftUI calls this method for any\n    /// changes affecting the corresponding UIKit view. Use this method to\n    /// update the configuration of your view to match the new state information\n    /// provided in the `context` parameter.\n    func updateUIView(_ uiView: Self.UIViewType, context: Self.Context)\n    ```\n","n":0.067}}},{"i":13,"$":{"0":{"v":"iOS Version Check","n":0.577},"1":{"v":"\n## `#available(iOS 17, *)`\n\n檢查OS版本來決定要不要運行code\n\n```swift\nif #available(iOS 17, *) {\n    print(\"this code only runs on iOS 17 and up\")\n} else {\n    print(\"this code only runs on iOS 16 and lower\")\n}\n```\n\n## `@available(iOS 17, *)`\n\n定義class/method時標註可被調用的OS版本\n\n```swift\n@available(iOS 17, *)\nfinal class Camera {\n    // ..\n}\n```","n":0.162}}},{"i":14,"$":{"0":{"v":"Firebase","n":1}}},{"i":15,"$":{"0":{"v":"Cloud Messaging","n":0.707}}},{"i":16,"$":{"0":{"v":"Cloud Firestore","n":0.707},"1":{"v":"\n## Keywords\n\n- NoSQL\n- document-oriented database\n\n## What is a document in firestore?\n\nA lightweight record that contains fields, which map to values.\n\n> arrays or nested objects, are called maps\n\n## What is a reference in firestore?\n\nA reference is a lightweight object that just points to a location in your database.\n\n- 拿`collection reference`：\n  - querying the documents in the collection\n\n- 拿`document reference`:\n  - 對該document進行讀寫\n\n拿Reference的小技巧：\n\n```swift\nlet documnetRef = db.document(\"users/jason\")\n```\n\n## Index types in Cloud Firestore\n\n1. single-field indexes\n2. composite indexes\n\n## Data Structuring for cloud firestore\n\n- Always store numbers as doubles\n\n### Options\n\n1. Document：\n2. MultiCollections:\n3. SubCollections within documents:\n\n## Write\n\n### Options\n\n1. 在某個集合中新增檔案，並指定DocumentID\n2. 在某個集合中新增檔案，使用Cloud Firestore自動產生的DocumentID\n3. 在某個集合中新增空檔案（使用Cloud Firestore自動產生的DocumentID），日後在增加資料\n\n### Set document\n\n> 建立 / 覆蓋某個檔案\n\n```swift\n// Update one field, creating the document if it does not exist.\ndb.collection(\"cities\").document(\"BJ\").setData([ \"capital\": true ], merge: true)\n```\n\n如果使用`set()`建立檔案，一定需要給一個DocumentID，但是不是每次我們要建立的資料的ID都需要我們自己產生，這時候可以使用`add()`，這樣就可以請Cloud Firestore幫我們建立這筆資料的DocumentID\n\n> Behind the scenes, .add(...) and .doc().set(...) are completely equivalent, so you can use whichever is more convenient.","n":0.086}}},{"i":17,"$":{"0":{"v":"WebRTC signalling","n":0.707},"1":{"v":"\n## 如何用Firebase Collection建立一個signalling server?\n\n### 建立一個直播間\n\n1. 建立一個Stream Collection，紀錄存在的直播間\n2. 當使用者按下直播時，我們會透過`WebRTCClient`的`peerConnection`產生一個`RTCSessionDescription`(後續簡稱`sdp`，代表發起直播者提供的`offer`)，他產生的`sdp`我們會將它設為local description。接下來，我們會在Stream Collection建立一個新Document，並將這個`sdp`的資訊存在這個Document中，並給一個`offer`的key。\n\n    ```javascript\n\n    offer: {\n      type: offer.type,\n      sdp: offer.sdp\n    }\n\n    ```\n\n3. 我們開始監聽這個直播間是否有人進入，如果有的話，將這個進來的人的`sdp`設為發起直播者的remote description\n\n### 加入一個直播間\n\n1. 使用者選擇一個想看的直播間，並按下加入，我們會將使用者的remote description設定成開啟直播者的`sdp`，並請`WebRTCClient`的`peerConnection`產生一個`answer`的`sdp`，並將其設為local description。\n\n2. 將產生的answer `sdp`寫入該直播間的document field\n\n    ```javascript\n    answer: {\n      type: answer.type,\n      sdp: answer.sdp\n    }\n    ```\n\n3. 這時候開啟直播的人就會監聽到stream doc的變動，並將加入者的`sdp`設為其remote description，並完成了發起直播與加入直播之間的`sdp`交換\n\n### Collect ICE candidates\n\n","n":0.152}}},{"i":18,"$":{"0":{"v":"Dependency Injection","n":0.707},"1":{"v":"\n## Dependency Injection\n\nCommon used cases:\n\n- When initializing a provider, we might pass in a dataService for the provider to init, and then the provdier can use that dataService instance to fetch Data.\n\n- When using `#Preview` in swiftUI, some views depends on the environment values when rendering the view, so we might use an environment modifier to inject the values that we want to see on the preview canvas.","n":0.121}}},{"i":19,"$":{"0":{"v":"Data Structure","n":0.707},"1":{"v":"\n## Struct vs Class vs Actor\n\n### struct\n\n```swift\nstruct MyStruct {\n  var title: String\n}\n\nvar structObject = MyStruct(title: \"myStruct\")\n\nstructObject.title = \"updated myStruct\" // This one is a whole new struct object\n```\n\n### Class\n\n### Actor\n\n```swift\nactor MyDataManager {\n static let instance = MyDataManager()\n\n private init() {}\n\n var data: [String] = []\n\n func getRandomData() -> String? {\n  self.data.append(UUID().uuidString)\n  print(Thread.current)\n  return self.data.randomElement()\n }\n}\n```\n\n> Classes that are thread safe.\n\n## Class vs Struct ?\n\nThere is much less need to worry about memory leaks or multiple threads racing to access / modeify a single instance of a variable.\n\n## Value vs Reference types\n\ntypes | Struct | Class | Actor | Function\n---------|:----------:|:---------:|:--------:|:------:|\n type | Value | Reference | Reference | Reference\n Stored in | Stack | Heap | Heap | Heap\n Speed | Faster | Slower | Slower\n Thread safe | V | X | V | X\n Inheritance | X | V | X | X\n\n## Stack vs Heap\n\nValue based data types are stored in stack\n\nReference based data types are stored in heap\n\n### Stack\n\n- Each thread has it's own stack!\n- Variables allocated on the stack are stored directly to the memory, and access to this memory is very fast\n\n### Heap\n\n- Shared across threads!\n\n![](/assets/images/project%20brainstorming.flavor%20flash%20journal.thread_struct_heap.png)\n\n## Automatic Reference Counting (ARC)\n\nvalue types such as structures and enumerations are just copying the data to data. Therefore it's not affected by ARC.\n\nARC is used to track and manage the app's memory usage. When class instances are no longer needed, ARC automatically frees up the memory used by that class.\n\n這也是為什麼esacaping closure通常會需要標註`weak self`的原因，以免當某個class不需要被使用時，卻因為某個closure中有引用到strong self而無法正常釋放記憶體。\n\n## Situations when choosing different data types\n\n1. Structs:\n   1. Data Models\n   2. SwiftUI Views\n\n2. Classes:\n   1. ViewModels\n\n3. Actors:\n   1. Shared 'Manager' / 'Data Store'\n\nReferences:\n- https://www.backblaze.com/blog/whats-the-diff-programs-processes-and-threads/","n":0.061}}},{"i":20,"$":{"0":{"v":"Core Data","n":0.707},"1":{"v":"\n## SwiftUI 中導入Core Data\n\n1. 建立Data Model\n2. 建立DataController / DataManagar Helper class，負責初始化data model persistent store\n3. 在App入口初始化DataController，並透過`@environmnet(\\.managedObjectContext, dataController.container.viewContext)`讓整個view hiearchy 都可以存取到\n\n## 如何使用 `@FetchRequest` property wrapper?\n\n> Always declare properties that have a fetch request wrapper as private.\n","n":0.174}}},{"i":21,"$":{"0":{"v":"Concurrency","n":1},"1":{"v":"\n## Download image\n\n### Old way (escaping closure)\n\nURLSession + escaping completionHandler closure\n\n```swift\nfunc responseHandler(_ data: Data?,_ response: URLResponse?) -> UIImage? {\n    guard\n        let data,\n        let image = UIImage(data: data),\n        let response = response as? HTTPURLResponse,\n        response.statusCode >= 200 && response.statusCode < 300 else {\n          return nil\n        }\n\n        return image\n}\n\n// old school\nfunc downloadWithEscaping(completionHandler: @escaping (_ image: UIImage?, _ error: Error?) -> ()) {\n    URLSession.shared.dataTask(with: URL(string: \"xxx\")) { [weak self] (data, response, error) in\n        let image = responseHandler(data, response)\n        completionHandler(image, error)\n    }\n}\n\n// with combine\nfunc downloadWithCombine() -> AnyPublisher<UIImage?, Error> {\n    URLSession.shared.dataTaskPublisher(for: url)\n        .map(responseHandler)\n        .mapError { $0 }\n        .eraseToAnyPublisher()\n}\n```\n\n### New way (async await)\n\n```swift\nfunc downloadWithAsync() async throws -> UIImage {\n    let (imageData, response) = try await URLSession.shared.data(from: URL(string: \"xxx\")!)\n\n    guard let image = responseHandler(imageData, response) else {\n        throw URLError(.badServerResponse)\n    }\n\n    return image\n}\n```\n\n## How to load multiple images concurrently?\n\n### Problem: loading images in a Task context loads by serial\n\n```swift\nstruct AsyncLetView: View {\n    @State private var images: [UIImage] = []\n\n    @StateObject private var loadImageViewModel = LoadImageViewModel()\n\n    let columns = [GridItem(.flexible()), GridItem(.flexible())]\n\n    var body: some View {\n        LazyVGrid(columns: columns) {\n            ForEach(images, id: \\.self) { image in\n                Image(uiImage: image)\n                .resizable()\n                .scaledToFit()\n                .frame(height: 150)\n            }\n        }\n        .onAppear {\n            Task {\n                let image1 = try await loadImageViewModel.fetchImage()\n                self.images.append(image1)\n                let image2 = try await loadImageViewModel.fetchImage()\n                self.images.append(image2)\n                let image3 = try await loadImageViewModel.fetchImage()\n                self.images.append(image3)\n                let image4 = try await loadImageViewModel.fetchImage()\n                self.images.append(image4)\n            }\n        }\n    }\n}\n```\n\n### Solution 1: Split in different Task\n\n> Cons: bad code\n\n```swift\n   Task {\n    let image1 = try await loadImageViewModel.fetchImage()\n    self.images.append(image1)\n\n   }\n\n   Task {\n    let image2 = try await loadImageViewModel.fetchImage()\n    self.images.append(image2)\n   }\n\n   Task {\n    let image3 = try await loadImageViewModel.fetchImage()\n    self.images.append(image3)\n   }\n\n   Task {\n    let image4 = try await loadImageViewModel.fetchImage()\n    self.images.append(image4)\n   }\n```\n\n### Solution 2: `async let`\n\n> Cons: Better than solution 1, but still not scalable\n\n```swift\nTask {\n    async let fetchImage1 = try await loadImageViewModel.fetchImage()\n    async let fetchImage2 = try await loadImageViewModel.fetchImage()\n    async let fetchImage3 = try await loadImageViewModel.fetchImage()\n    async let fetchImage4 = try await loadImageViewModel.fetchImage()\n\n    let (image1, image2, image3, image4) = try await (fetchImage1, fetchImage2, fetchImage3, fetchImage4)\n\n    images.append(contentsOf: [image1, image2, image3, image4])\n}\n```\n\n### Solution 3: TaskGroup\n\n> Pros: Better than above solution, clean on handling multiple tasks\n> Cons: Need to be careful of the error handling\n\n```swift\nstruct User: Codable {\n    let id: String\n\n    let name: String\n}\n\nfunc fetchUsersWithTaskGroup(ids: [String]) async throws -> [User] {\n    var users: [User] = []\n\n    return try await withThrowingTaskGroup(of: User?.self) { group in\n        for id in ids {\n            group.addTask {\n                try? await fetchUser(userId: id)\n            }\n        }\n\n        for try await user in group {\n            if let user {\n                users.append(user)\n            }\n        }\n\n      return users\n    }\n}\n```\n\n## SDK 不支援 async await （使用completionHandler）\n\n### Solution: 使用`withCheckedThrowingContinuation`包\n\n```swift\nfunc getData(url: URL) async throws -> Data {\n    return try await withCheckedThrowingContinuation { continuation in\n        URLSession.shared.dataTask(with: url) { data, response, error in\n            if let data {\n                continuation.resume(returning: data)\n            } else if let error {\n                continuation.resume(throwing: error)\n            } else {\n                continuation.resume(throwing: URLError(.badURL))\n            }\n        }\n        .resume()\n    }\n}\n```\n\n## 問題： 在還沒有actor之前，要如何解決不同物件之間對同一個class的存取/修改？\n\nA: 在有可能被同時存取的class中宣告特定的Queue，規範某些需要排隊處理的操作。\n\n## What is global Actors?\n\n## What is `@MainActor`?\n\n當某個資料會影響到UI時，會需要標記`@MainActor`，告訴compiler說這個資料需要在main thread做更新才可以確保thread safety。\n\n通常在有標記`@Published`的variable都會需要標記`@MainActor`，或是直接在viewModel標記也可以。\n\n## What is Sendable protocol?\n\n當某個type遵守`Sendable`協議時，並不需要特別定義properties或methods，只是要確保在併發環境下，某個property可以保證thread safe就是符合`Sendable`協議。\n\n> 定義struct時，通常就默認遵守Sendable (value types)\n\n## Manage strong & weak reference with Async / Await?\n\n通常不需要在Task呼叫的closure中做weak self的記憶體管理，而是在Task層面。\n\n如果在ViewModel中做了很多async await的操作，可以將Task的Reference紀錄起來，當View disappear的時候去一一cancel還正在執行的Task。\n\n## MVVM 中使用Async / Await 的 Pattern\n\n相較於在View中使用Task包住ViewModel的function，如果情況允許的話，在ViewModel的function中用Task包住concurrent的code會比較好管理這些Task。","n":0.045}}},{"i":22,"$":{"0":{"v":"Community","n":1},"1":{"v":"\n## QRCode 掃條碼\n\n### 產生QRCode\n\n透過CoreImage的`CIFilter`物件來處理輸入的image data\n\n(CIImage本身不是可以display的view物件，需要先轉成UIImage)\n\n```swift\nimport CoreImage.CIFilterBuiltins\n\nfunc generateQRCode(from string: String) -> UIImage {\n  let context = CIContext()\n  let filter = CIFilter.qrCodeGenerator()\n\n  filter.message = Data(string.utf8)\n\n  if let outputImage = filter.outputImage {\n    if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {\n      return UIImage(cgImage: cgImage)\n    }\n  }\n\n  return UIImage(systemName: \"xmark.circle\") ?? UIImage()\n}\n```","n":0.146}}},{"i":23,"$":{"0":{"v":"Architecture","n":1},"1":{"v":"\n## Dependency Injection\n\nQ: What did it solve?\n\nA: Singleton design pattern cons\n\n### How it works?\n\n> Use protocols to make a blue print of DataServices\n\n1. Initializing dataServices at a intro level (Can use a Master class to initialize all dataServices)\n2. Passing these dataService instances into Views and use it to initialize view models (Injection)\n\n## Singleton\n\n- Pros:\n\n  1. Very convenient\n  2. Beginner friendly\n\n- Cons:\n\n  1. Singleton's are global (not thread safe)\n  2. can't customize init (bad for testing)\n  3. can't swap out service\n\n## App LifeCycle\n\nPrior to iOS 14, iOS apps had a class named \"AppDelegate\" that the creation of this class was the starting point of an app.\n\n### `@Main` property wrapper\n\nIndicates the entry execution of the app\n\n### 'App' protocol\n\nstruct that conform to the App protocol, has a default implementation of the method `main()`, which manages the launch process of the app.","n":0.085}}},{"i":24,"$":{"0":{"v":"View","n":1},"1":{"v":"\n## Container Views\n\n### VStack -> Vertical\n\n### HStack -> Horizontal\n\n### ZStack -> zIndex (back to front)\n\n> VStack, HStack has default spacing.\n\n## Common Modifiers\n\n### `.frame()`\n\n```swift\nText(\"Hello, World!\")\n  .background(.blue)\n  .frame(width: 300,height: 200, alignment: .bottom)\n  .background(.red)\n```\n\nview before the `.frame()` modifier will be the content of the frame.\n\n### `.background()`是可以不斷疊加上去的\n\n### `.overlay`會在background之上\n\n> background, overlay 設定的alignment是對齊Self的frame.\n\n## `background` vs `ZStack`\n\n當堆疊很多物件時，使用`ZStack`，單純的情況就盡量使用`background`\n\n## 善用`Spacer()`推 Stack 裡面的laout\n\n## How to use `enum` and `init` in swiftUI reusable views\n\n## ScrollView 小技巧\n\n> 可以nest，如果想要做瀑布流可以考慮\n\n```\nScrollView -> VStack -> **ForEach** -> ScrollView -> HStack -> **ForEach** -> RoundedRectangle\n```\n\n如果資料比較多，我們應該要使用LazyVStack, LazyHStack\n\n## Conditional Rendering\n\n1. if else statements ( `||`, `&&` )\n2. ternary operators\n\n\n## Action sheet, Alert view 都是可以封裝成viewBuilder的","n":0.103}}},{"i":25,"$":{"0":{"v":"Reusable View","n":0.707},"1":{"v":"\n## 管理要渲染哪個Loading View的Container View\n\n```swift\npublic struct ActivityIndicatorView: View {\n\n    public enum IndicatorType {\n        case `default`(count: Int = 8)\n        case arcs(count: Int = 3, lineWidth: CGFloat = 2)\n        case rotatingDots(count: Int = 5)\n        case flickeringDots(count: Int = 8)\n        case scalingDots(count: Int = 3, inset: Int = 2)\n        case opacityDots(count: Int = 3, inset: Int = 4)\n        case equalizer(count: Int = 5)\n        case growingArc(Color = .black, lineWidth: CGFloat = 4)\n        case growingCircle\n        case gradient(_ colors: [Color], CGLineCap = .butt, lineWidth: CGFloat = 4)\n    }\n\n    @Binding var isVisible: Bool\n    var type: IndicatorType\n\n    public init(isVisible: Binding<Bool>, type: IndicatorType) {\n        _isVisible = isVisible\n        self.type = type\n    }\n\n    public var body: some View {\n        if isVisible {\n            indicator\n        } else {\n            EmptyView()\n        }\n    }\n\n    // MARK: - Private\n\n    private var indicator: some View {\n        ZStack {\n            switch type {\n            case .default(let count):\n                DefaultIndicatorView(count: count)\n            case .arcs(let count, let lineWidth):\n                ArcsIndicatorView(count: count, lineWidth: lineWidth)\n            case .rotatingDots(let count):\n                RotatingDotsIndicatorView(count: count)\n            case .flickeringDots(let count):\n                FlickeringDotsIndicatorView(count: count)\n            case .scalingDots(let count, let inset):\n                ScalingDotsIndicatorView(count: count, inset: inset)\n            case .opacityDots(let count, let inset):\n                OpacityDotsIndicatorView(count: count, inset: inset)\n            case .equalizer(let count):\n                EqualizerIndicatorView(count: count)\n            case .growingArc(let color, let lineWidth):\n                GrowingArcIndicatorView(color: color, lineWidth: lineWidth)\n            case .growingCircle:\n                GrowingCircleIndicatorView()\n            case .gradient(let colors, let lineCap, let lineWidth):\n                GradientIndicatorView(colors: colors, lineCap: lineCap, lineWidth: lineWidth)\n            }\n        }\n    }\n}\n```\n\n1. 先定義Enum，代表這個Container View可以渲染的Loading View有哪些\n\n2. 定義`init`方式 (傳入一個`isVisible`的Binding variable、一個上面定義好的Loading Type)\n\n3. 透過`computed value`決定這個view要渲染哪個Loading View\n\n## Loading View怎麼設計的\n\n先決定Loading想要的變化(Ex: 透明度、長度、變形)\n\n## How to extract Subviews\n\n1. Simple view => 拆成其他computed value就可以\n2. Need reusability(stateful view) => extract into subview","n":0.065}}},{"i":26,"$":{"0":{"v":"PreferenceKey","n":1},"1":{"v":"\n## `.navigationTitle(_ title: String)` 是怎麼運作的？\n\n通常在child view中要改變parent view的值我們會使用Binding的方式，但是像navigationTitle這種modifier我們並沒有做綁定，為什麼還是可以在任何child view中改變parent view的navigationTitle呢？\n\n當某個View透過modifier設定navigationTitle時，實際上是透過PreferenceKey去改變最父層的navigationTitle\n\n```swift\nstruct CustomPreferenceKey: PreferenceKey {\n  static var defaultValue: String = \"\"\n\n  static func reduce(value: inout String, nextValue: () -> String) {\n    value = nextValue()\n  }\n}\n```\n\n- Steps:\n  1. 建立一個遵從`PreferenceKey`的struct\n  2. Parent View 用`onPreferenceChange`modifier監聽\n  3. Child View用`preference(key: RectGeoPreferenceKey.self, value: size)`改變自定義的struct\n\n## 使用情境\n\n1. 監聽`scrollView`中某個View的offset","n":0.146}}},{"i":27,"$":{"0":{"v":"Grid","n":1},"1":{"v":"\n## `LazyVGrid` Instagram layout\n\n```swift\nstruct LazyVGridView: View {\n    var body: some View {\n    ScrollView {\n    Rectangle()\n      .fill(AngularGradient(colors: [.blue, .purple, .red], center: .bottomLeading))\n      .frame(width: .infinity, height: 500)\n\n    LazyVGrid(\n        columns: [\n            GridItem(.flexible(), spacing: 10),\n            GridItem(.flexible(), spacing: 10),\n            GridItem(.flexible(), spacing: 10),\n        ],\n        alignment: .leading,\n        spacing: 10,\n        pinnedViews: [.sectionHeaders],\n        content: {\n            Section {\n              ForEach(0..<20) { index in\n                  Rectangle()\n                    .frame(height: 150)\n              }\n            } header: {\n              Text(\"This is Section 1\")\n                  .font(.subheadline)\n                  .foregroundStyle(.brown)\n            }\n        })\n    }\n    }\n}\n\n```","n":0.12}}},{"i":28,"$":{"0":{"v":"Divider","n":1},"1":{"v":"\n## ------ Text ------ Effect\n\n```swift\nDivider()\n  .frame(height: 2)\n  .overlay(.gray)\n  .padding()\n  .overlay {\n    Text(\"Continue with Email\")\n      .font(.caption)\n      .padding(.horizontal, 10)\n      .background(.black)\n  }\n```","n":0.229}}},{"i":29,"$":{"0":{"v":"Clean UI Code","n":0.577},"1":{"v":"\n## Clean UI code in swiftUI\n\nYou can organize UI code using the following techniques to maintain cleaner UI code in your project:\n\n1. ViewModifiers\n2. ViewBuilders\n3. extract subviews","n":0.196}}},{"i":30,"$":{"0":{"v":"Shape","n":1},"1":{"v":"\n\n## 畫邊框\n\n```swift\nCircle()\n  .stroke(\n    Color.green,\n    style: StrokeStyle(lineWidth: 10, lineCap: .square, dash: [40])\n  )\n```\n\n![Circle stroke](/assets/images/project%20brainstorming.flavor%20flash%20journal.View.CircleStroker.png)\n\n```swift\nstruct PathView: View {\n    var body: some View {\n  ZStack {\n   Path { path in\n    path.move(to: CGPoint(x: 20, y: 100))\n    path.addLine(to: CGPoint(x: 370, y: 100))\n   }\n   .stroke(style: StrokeStyle(lineWidth: 30, lineCap: .square))\n  }\n    }\n}\n```\n\n![linecap](/assets/images/project%20brainstorming.flavor%20flash%20journal.View.stroke_linecap.png)\n\n```swift\n  GeometryReader { geometry in\n   ZStack {\n    Path { path in\n     path.move(to: CGPoint(x: geometry.size.width / 2, y: 100))\n     path.addLine(to: CGPoint(x: geometry.size.width / 2 - 50, y: 200))\n     path.addLine(to: CGPoint(x: geometry.size.width / 2 + 50, y: 200))\n    }\n    .stroke(style: StrokeStyle(lineWidth: 30, lineCap: .square, lineJoin: .round))\n   }\n  }\n```\n\n![lineJoin](/assets/images/project%20brainstorming.flavor%20flash%20journal.View.lineJoin.png)\n\n`strokeStyle` init parameters:\n\n1. lineCap: 控制線條尾端的形狀\n   1. round 圓尾\n   2. square、butt 方形尾\n      > 如果想要嚴格控制物件的大小 => butt，因為square的方形尾會超出起點＆終點\n\n2. lineJoin: 控制線條的連接style\n   1. round、milter、bevel\n3. dash: 控制虛線樣式&間隔的長度\n\n### 搭配`trim`做一個Loading的動畫\n\n```swift\nimport SwiftUI\nimport Combine\n\nstruct CircleView: View {\n\n @State var progress: CGFloat = 0\n let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()\n\n    var body: some View {\n      Circle()\n        .trim(from: 0.0, to: progress)\n        .stroke(Color.green, lineWidth: 20)\n        .frame(width: 200, height: 200)\n        .onReceive(timer, perform: { _ in\n          addProgress()\n   })\n }\n\n func addProgress() {\n  if progress >= 1.0 {\n   progress = 0.1\n  } else {\n   progress += 0.1\n  }\n }\n}\n```\n\nWithout using Combine ↓\n\n```swift\nstruct CircleView: View {\n\n @State var progress: CGFloat = 0\n\n    var body: some View {\n      Circle()\n        .trim(from: 0.0, to: progress)\n        .stroke(Color.green, lineWidth: 20)\n        .frame(width: 200, height: 200)\n        .onAppear {\n          let setTimer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { timer in\n            addProgress()\n          }\n        }\n }\n\n func addProgress() {\n  if progress >= 1.0 {\n   progress = 0.1\n  } else {\n   progress += 0.1\n  }\n }\n}\n```\n","n":0.065}}},{"i":31,"$":{"0":{"v":"Tips","n":1},"1":{"v":"\n## Preview\n\n可以建立static的function建立假的資料給Preview測試不同情境下畫面的顯示","n":0.707}}},{"i":32,"$":{"0":{"v":"Extensions","n":1},"1":{"v":"\n## `Color`\n\n```swift\nextension Color {\n  static func generateRandomColor() -> Self {\n  enum RColor: Int {\n    case red = 0, green = 1, blue = 2, yellow = 3\n\n    var color: Color {\n      switch self {\n      case .blue: return Color.blue\n      case .green: return Color.green\n      case .yellow: return Color.yellow\n      case .red: return Color.red\n      }\n    }\n  }\n\n  let random = Int.random(in: 0...3)\n\n  return RColor(rawValue: random)!.color\n  }\n}\n```\n","n":0.127}}},{"i":33,"$":{"0":{"v":"Animation","n":1},"1":{"v":"\n## 3 ways of implementing animation in swiftUI\n\n1. By `.animation` modifier\n\n    ```swift\n    struct PersonMoveView: View {\n\n    @State private var moveDistance: CGFloat = 0\n\n      var body: some View {\n      Button {\n        moveDistance += 100\n      } label: {\n        Text(\"移動\")\n      }\n\n      Image(.jason)\n        .resizable()\n        .scaledToFit()\n        .offset(x: moveDistance)\n        .animation(.bouncy, value: moveDistance)\n      }\n    }\n    ```\n\n2. `withAnimation`\n\n    ```swift\n        struct PersonMoveView: View {\n\n      @State private var moveDistance: CGFloat = 0\n\n        var body: some View {\n        let animation = Animation.easeInOut(duration: 0.2).delay(0.2).repeatForever(autoreverses: true)\n\n        Button {\n          moveDistance += 100\n        } label: {\n          Text(\"移動\")\n        }\n\n        Image(.jason)\n          .resizable()\n          .scaledToFit()\n          .offset(x: moveDistance)\n          .animation(.bouncy, value: moveDistance)\n          .onAppear {\n            withAnimation(animation) {\n              moveDistance += moveDistance == 100 ? -100 : 100\n            }\n          }\n        }\n    }\n    ```\n\n3. calling `animation` on `Binding` values\n\n## Transition\n\n1. 類似sheet的酷東東\n\n    ```swift\n    struct TransitionView: View {\n\n      @State private var showView: Bool = false\n\n      var body: some View {\n        ZStack(alignment: .bottom) {\n          VStack {\n            Button(\"Button test transition\") {\n              withAnimation(.easeInOut) {\n                showView.toggle()\n              }\n            }\n\n            Spacer()\n          }\n\n          if showView {\n            RoundedRectangle(cornerRadius: 30.0)\n              .frame(height: UIScreen.main.bounds.height * 0.5)\n              .transition(.move(edge: .bottom))\n          }\n        }\n        .ignoresSafeArea(edges: .bottom)\n        }\n    }\n    ```\n\n2. `asymmetric`可以做進出場的控制\n\n    ```swift\n    .transition(\n        AsymmetricTransition(\n            insertion: .move(edge: .bottom), removal: .move(edge: .trailing)))\n    ```\n\n### Transition vs Animation 的使用時機？\n\nview原本就在螢幕上，且單純想做搖擺等動畫 => animation\n\n要新增某個view到現有的view => Transition + conditional rendering\n\n## Sheet vs Transition vs Animation offset","n":0.072}}},{"i":34,"$":{"0":{"v":"Language","n":1}}},{"i":35,"$":{"0":{"v":"Swift","n":1}}},{"i":36,"$":{"0":{"v":"Tip","n":1},"1":{"v":"\n## Pretty print debug console\n\n- use \"dump\"\n\n## Local Reasoning","n":0.333}}},{"i":37,"$":{"0":{"v":"Protocol","n":1},"1":{"v":"\n## What is Protocol?\n\n> A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be adopted by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to conform to that protocol.\n\nProtocol是功能的藍圖，定義好可以交由Type實現功能。\n\n舉例來說，我們是老闆，我們再請工廠生產我們的產品之前，先給工廠一個產品的requirement，讓我們兩種不同產品，都提供一些相同功能。\n\nex: 可以旋轉、可以變色等等\n\n這些功能是我們的最低要求，我們請工廠一定在建立產品之前，要符合這些功能給我們產品的藍圖，再去實際生產\n\n## Why do we need Protocols?\n\n## Protocol Requirements\n\n### properties\n\n```swift\n\n```\n\n### functions\n\n- 如果用**mutating**標記function的草稿，在實作class method時不必再寫一次在method前，但struct, enum時需要。\n\n> 為什麼需要mutating標記呢？\n>\n> protocol 本身並不會定義function，只定義**名字**、**參數**、**回傳值**。 但是有時候還是很難透過這三個東西去表示這個function實作時需要注意的事，像是會不會去更改到該Type的stored properties，但如果用mutating前綴作為標記的話，就可以一目瞭然，知道這個function實作時會更改到stored property。\n\n```swift\nenum OnOffSwitch: Togglable {\n    case off, on\n    // class實作時不需要再標記為mutating\n    mutating func toggle() {\n        switch self {\n        case .off:\n            self = .on\n        case .on:\n            self = .off\n        }\n    }\n}\nvar lightSwitch = OnOffSwitch.off\nlightSwitch.toggle()\n```\n\n### initializers\n\n```swift\nprotocol SomeProtocol {\n    init(someParameter: Int)\n}\n// 實作時要加上`required`，但如果標記為`final`的class，則可以不必\nclass SomeClass: SomeProtocol {\n    required init(someParameter: Int) {\n        // initializer implementation goes here\n    }\n}\n```\n\n## Protocol vs Inheritance\n\nStruct, Enum 是無法被繼承的Type，但我們可以透過讓這些Type遵循某個共同的Protocol去讓Type之間有一些很相似的特性。\n\n## Note：\n\n- Protocol 也是一個類別\n\n> 有時候instance之間並沒有共同superclass，但是有共同的功能，這時候就可以透過protocol的type讓他們有以功能分類的概念。\n\n```swift\nlet objects: [AnyObject] = [Circle(radius: 10), Sun(radius: 100), Frisbee(radius: 50), Square(width: 10)]\n\nfor object in objects {\n  if let roundObject = object as? Round {\n    print(\"round object\")\n  } else {\n    print(\"not round\")\n  }\n}\n```\n\n- Protocol 可以其他 Protocol 繼承\n- Protocol 可以互相組合\n- -@objc protocols can be adopted only by classes, not by structures or enumerations\n- Protocol 搭配 extension 做","n":0.072}}},{"i":38,"$":{"0":{"v":"Delegate","n":1},"1":{"v":"\n> 一種物件之間溝通的Design Pattern\n\n## 舉例\n\n1. 當點擊某個button的時候，我們並沒有將點擊button要發生的事寫在button的元件裡，而是在button點擊時，讓他觸發delegate的function，達到類似監聽點擊事件通知的功能。\n2. 以TableView為例，\n\n## 實作方式\n\n1. 找到需要\n\n## 搭配 Extension\n\n```swift\n\n```","n":0.316}}},{"i":39,"$":{"0":{"v":"Performance","n":1},"1":{"v":"\n## Dimensions of Performance\n\n1. Allocation\n   1. stack & heap\n2. Reference Counting\n3. Method Dispatch\n\n### Allocation\n\n記憶體儲存的位置，\n\n如果沒有identity, indirect storage的需求，使用struct會比class有更好的效能。\n\n#### Dynamic / Static Dispatch\n\n- Dynamic:\n  1. Table Dispatch(witness table)\n  2. Message Dispatch(KVO, Core Data)\n- Static:\n  1.","n":0.177}}},{"i":40,"$":{"0":{"v":"Grand Central Dispatch","n":0.577},"1":{"v":"\n![GCD_icon](./assets/images/language.swift.grand-central-dispatch_icon.png)\n\n```mermaid\ngraph TB;\nA[Grand Central Dispatch] --> B[Why do we need it?]\nA --> C[How did it work?]\nA --> D[Alternatives]\n```\n\n## What is Grand Central Dispatch?\n\n> Dispatch, also known as Grand Central Dispatch (GCD), contains language features, runtime libraries, and system enhancements that provide systemic, comprehensive improvements to the support for concurrent code execution on multicore hardware in macOS, iOS, watchOS, and tvOS.\n\n一個讓工程師可以更輕易配置**concurrent code**的框架\n\n## What problem did **GCD** solve?\n\n執行緒管理 | 人工 | GCD\n---------|----------|---------\n (維護 / 開發)難度 | 較高  | 較低\n 平均效能 | 1 | 1.3\n 安全性 | 不一定 | 安全\n\n## How did it Work?\n\nGCD是一個讓我們可以不用直接操作Thread的API，我們只需要指定Task的**性質**，並將他加入適當的**DispatchQueue**，GCD就可以幫我們處理這些Task應該要在哪個Thread被執行。\n\n### Before GCD\n\n```mermaid\ngraph TD\nA[Program] --> B[Create Threads]\nB --> C[Define Thread Functions]\nC --> D[Start Threads]\nD --> E[Thread1: Task1]\nD --> F[Thread2: Task2]\nD --> G[Thread3: Task3]\nE --> H[Thread Synchronization]\nF --> H\nG --> H\nH --> I[Continue Execution]\n```\n\n### After GCD\n\n```mermaid\ngraph TD\nA[Program] --> B[Dispatch Queue1]\nA[Program] --> C[Dispatch Queue2]\nB --> D[Task1]\nB --> E[Task2]\nC --> F[Task3]\nC --> G[Task4]\n```\n\n## Parallelism and Concurrency\n\n> ### Explaination from WWDC2017 GCD\n>\n> - Parallelism\n>\n>   Simultaneous execution of closely related computations\n> - Concurrency\n>\n>   Composition of independently executed tasks\n\n## Queue Concept\n\n當我們提交Task到DispatchQueue中，GCD會依照先進先出(FIFO)的規則依序執行我們的Task。\n\n我們僅需要注意：\n\n- 選擇對的DispatchQueue( Serial / Concurrent )\n- 執行對的dispatching function( sync / async )\n\n### DispatchQueue\n\n#### Serial vs Concurrent\n\nDispatchQueue Type | Serial | Concurrent\n---------|:----------:|:---------:\n 可預測 | 可以 | 不一定\n 發生Race Condition | 不可能 | 可能\n 完成Task的速度 | 慢 | 快\n\n#### Sync vs async\n\n> Dispatch Function is just a function that tells the queue how this task should be scheduled\n\n```swift\nlet backgroundQueue = DispatchQueue.global()\nbackgroundQueue.sync {\n  // Task1\n  print(\"task1\")\n}\n\nprint(\"between sync\")\n\nbackgroundQueue.async {\n  // Task2\n  print(\"task2\")\n}\n\n// output:\n// task1\n// between sync\n// task2\n```\n\n```swift\nlet backgroundQueue = DispatchQueue.global()\nbackgroundQueue.async {\n  // Task1\n  print(\"task1\")\n}\n\nprint(\"middle\")\n\nbackgroundQueue.sync {\n  // Task2\n  print(\"task2\")\n}\n\nprint(\"bottom\")\n\n// output:\n// between async\n// task2\n// after all async\n// task1\n```\n\n```swift\nlet backgroundQueue = DispatchQueue.global()\nbackgroundQueue.async {\n  // Task1\n  print(\"small task done, on thread \\(Thread.current)\")\n  backgroundQueue.sync {\n    print(\"sync task, on thread \\(Thread.current)\")\n    backgroundQueue.async {\n      print(\"inside sync async task, on thread \\(Thread.current)\")\n    }\n  }\n}\n\nprint(\"between async\")\n\nbackgroundQueue.sync {\n  // Task2\n  print(\"task2\")\n}\n\nprint(\"after all async\")\n\n// output:\n// between async\n// task2\n// after all async\n// task1\n```\n","n":0.058}}},{"i":41,"$":{"0":{"v":"Parallelism","n":1},"1":{"v":"\n## 明確告訴GCD這個task要使用parellelism的方式去執行\n\n`DispatchQueue.concurrentPerform`","n":0.707}}},{"i":42,"$":{"0":{"v":"Concurrency","n":1},"1":{"v":"\n## 為什麼我們要好好的處理concurrency?\n\n設計良好的concurrency code可以讓我們充分使用到CPU的資源\n\n## 如何使用DispatchQueue?\n\n**DispatchQueue**就是幫我們管理Tasks的一個物件。\n\n### Step 1: 取得或建立一個DispatchQueue\n\n```swift\nlet mainQueue = DispatchQueue.main  // Serial\n\nlet globalQueue = DispatchQueue.global() // Concurrent\n\nlet customQueue = DispatchQueue(label: \"example.com.domain\") // default Serial\n```\n\n### Step 2: 我們可以透過以下方式提交Task到一個DispatchQueue物件上，並指定DispatchQueue要如何執行這個Task\n\n```swift\nglobalQueue.sync {\n  // Task1...\n}\n\nglobatQueue.async {\n  // Task2...\n}\n```\n\n## 什麼是DispatchItem？為何要使用他？\n\n如果我們想要控制我們的Task狀態呢？ ex: 在三秒內沒有回傳結果時我想要取消這個Task\n\n  1. 情境1:  使用者輸入UISearchBar時，不希望每次text change都打一次API，造成後端的負擔。\n\n      我們可以將Task透過DispatchItem封裝，再透過DispatchQueue設定asyncAfter延後執行這個DispatchItem，我們就可以達到延遲fetch資料，減少對後端的負載\n\n\n```swift\nlet workItem = DispatchWorkItem {\n  // Task1...\n}\n\nglobalQueue.async(execute: workItem)\n```\n\n## 什麼是DispatchGroup? 為何要使用他？\n\n  1. 情境1: 我們有一個陣列的api要打，我們希望他可以全部加載完再一次更新到畫面上\n\n```swift\nlet globalQueue = DispatchQueue.global()\nlet loadImageGroup = DispatchGroup()\n\nloadImageGroup.enter()\nglobalQueue.async {\n    task1() { response in\n        ...\n        loadImageGroup.leave()\n    }\n}\n\nloadImageGroup.enter()\nglobalQueue.async {\n    task2() { response in\n        ...\n        loadImageGroup.leave()\n    }\n}\n\n// 1. wait synchronously for all tasks to finish\nloadImageGroup.wait()\n// ↓ Tasks that need to be done after loadImageGroup's task are all done\nprint(\"all done\")\n\n\n// 2. adding a completion handler for loadImageGroup\nloadImageGroup.notify(queue: .main) {\n  // ui update code\n}\n\n```\n\n## 什麼是DispatchSemaphore？為何要使用他？\n\n## 什麼是Barrier？為何要使用他？\n\n當把Task加到Concurrent Queue中，有時候不同Thread的Task會需要共同存取+修改到某個Value，造成一些Bug。\n\n透過在submit一個task時設定這個Task被執行時不能有其他task存取到同一個共同資源，可以確保這個task執行時不會有其他存取到共同資源的Task在其他Thread中存取。\n\n![](/assets/images/language.swift.grand-central-dispatch.concurrency_barrierConcept.png)","n":0.094}}},{"i":43,"$":{"0":{"v":"Framework","n":1}}},{"i":44,"$":{"0":{"v":"UIKit","n":1}}},{"i":45,"$":{"0":{"v":"architecture","n":1},"1":{"v":"\n## Concept\n\nKeep local reasoning always in mind.\n\n## Protocol Oriented Programming\n\n## Allocation\n\n## Technique\n\n- Customization through composition\n- protocol for generic, reusable code (easy tests, seperate logics)\n- value semantics","n":0.196}}},{"i":46,"$":{"0":{"v":"SwiftUI","n":1}}},{"i":47,"$":{"0":{"v":"property wrappers","n":0.707},"1":{"v":"\n> Property Wrapper跟SwiftUI是同一年推出的，導致很多人會誤以為property wrapper也是SwiftUI框架中的一部份，但其實只是一個swift語言 5.1 的新功能。\n\n## What is Property Wrappers?\n\nThe `@propertyWrapper` is a Swift attribute used on structs, enums or classes\n\n> Property wrappers 是一個語法糖，告訴compiler說這個類別建立出來的實體有wrapped value這層setter / getter的包裝。\n\nREF: https://www.hackingwithswift.com/quick-start/swiftui/all-swiftui-property-wrappers-explained-and-compared\n\n1. `@AppStorage`: (Owns its data)\n   1. A easier way to manage userDefaults in swiftUI.\n2. `@Binding`: (Doesn't own its data)\n3. `@Environment`:\n   1. Reads data from the system. (ex: Color scheme, scenePhase)\n4. `@EnvironmentObject`: (Doesn't own its data)\n   1. Reads a shared Object that we placed into the environment.\n5. `@State`: (Owns its data)\n   1. Lets us manipulate small amounts of value type data locally to a view.\n6. `@StateObject`: (Owns its data)\n   1. Used to store new instances of reference type data that conforms to the `ObservableObject` protocol.\n7. `@ObservedObject`: (Doesn't own its data)\n   1. Refers to an instance of an external class that conforms to the `ObservableObject` protocol.\n8. `@Published`: (Owns its data)\n   1. Is attached to properties inside an 1, and tells SwiftUI that it should refresh any views that use this property when it is changed.","n":0.079}}},{"i":48,"$":{"0":{"v":"State","n":1},"1":{"v":"\n## What is `@State`?\n\n> A property wrapper type that can read and write a value managed by SwiftUI.\n\n## When to use it?\n\n> Use state as the single source of truth for a given value type that you store in a view hierarchy. Create a state value in an ``App``, ``Scene``, or ``View`` by applying the `@State` attribute to a property declaration and providing an initial value\n\n## Behind the scene\n\n> SwiftUI manages the property's storage. When the value changes, SwiftUI updates the parts of the view hierarchy that depend on the value. To access a state's underlying value, you use its `wrappedValue` property. However, as a shortcut Swift enables you to access the wrapped value by referring directly to the state instance.\n\nSwiftUI 中每個View都是以struct定義的，由於struct中的property是immutable，如果我們有一個variable是會改變的，而每次改變時我們希望View會重繪，那這時候我們就可以用`@State`這個SwiftUI定義好的property wrapper。當我們更改這個以`@State`定義的variable，SwiftUI就會幫我們更新View。\n\n在struct中宣告變數加上`@State`前綴，SwiftUI會將這個變數管理在一個shared storage(Redux like)，讓我們在View的重繪時不會遺失這個變數。\n\n從SwiftUI documentation可以看到`@State`定義的一些public property：\n\n```swift\n@propertyWrapper public struct State<Value>: DynamicProperty {\n    public init(wrappedValue value: Value)\n\n    public init(initialValue value: Value)\n\n    public var wrappedValue: Value { get nonmutating set }\n\n    public var projectedValue: Binding<Value> { get }\n}\n\npublic protocol DynamicProperty {\n\n    /// Updates the underlying value of the stored value.\n    ///\n    /// SwiftUI calls this function before rendering a view's\n    /// ``View/body-swift.property`` to ensure the view has the most recent\n    /// value.\n    mutating func update()\n}\n```","n":0.072}}},{"i":49,"$":{"0":{"v":"Published","n":1},"1":{"v":"\n## `ObservableObject` Protocol\n\n當我們宣告一個class遵守`ObservableObject` protocol時，我們是在告訴SwiftUI這個class可以被View所觀測。\n\n這個class中如果有property使用`@Published`標記，代表這當這個property變動時，所有引用到這個property的View都要重繪。\n\n## When to use it?\n\n> whenever an object with a property marked `@Published` is changed, all views using that object will be reloaded to reflect those changes.\n\n## Behind the scenes\n\n> the `@Published` property wrapper effectively adds a willSet property observer to items, so that any changes are automatically sent out to observers.","n":0.135}}},{"i":50,"$":{"0":{"v":"EnvironmentObject","n":1},"1":{"v":"\n## Why use it?\n\n當我們想要在View Hiearchy中共享某個物件，不想要一層一層傳遞該物件時，我們可以在View的最父層透過`environmentObject()`modifier，讓要使用的子層在View中以`@EnvironmentObject`去取得這個共享的物件。\n\n## What is it?\n\n他跟`@ObservedObject`有點像，都是參照符合`ObservableObject`protocol 的物件，差別在於:\n\n- `@ObservedObject`需要父層傳遞該Observable物件\n- `@EnvironmentObject`則是找到在到View階層環境中的Observable物件。\n  > SwiftUI會找尋該View階層中與宣告型別一樣的物件。\n\n## Behind the scenes\n\n```mermaid\n\n```\n\n## Example\n","n":0.243}}},{"i":51,"$":{"0":{"v":"StateObject","n":1},"1":{"v":"\n## What is `@StateObject`\n\n> A property wrapper type that instantiates an observable object.\n\n## When to use it?\n\n> Use a state object as the single source of truth for a reference type that you store in a view hierarchy.\n>\n> when you need to create a reference type inside one of your views and make sure it stays alive for use in that view and others you share it with.\n\n## Behind the scenes\n\n## Injecting `@StateObjects` into views\n\n```swift\nstruct MyInitializableView: View {\n    @StateObject private var model: DataModel\n    init(name: String) {\n        // SwiftUI ensures that the following initialization uses the\n        // closure only once during the lifetime of the view, so\n        // later changes to the view's name input have no effect.\n        _model = StateObject(wrappedValue: DataModel(name: name))\n    }\n    var body: some View {\n        VStack {\n            Text(\"Name: \\(model.name)\")\n        }\n    }\n}\n```\n\n## Force `@StateObject` property to reinitialize\n\n如果希望View中的reference type在View重繪時重新初始化，可以透過給定id modifier的方式去強迫這個reference type重新初始化（一般來說重繪View時，如果View的id沒有變化，SwiftUI就不會重新初始化這個 reference type property）\n\n## iOS 17.0 introduced `@Observable` macro\n\n- 使用`@Observable` macro 帶來什麼好處？\n\n  1. 寫更少扣：\n     1. 只要class前面帶有`@Observable`，裡面宣告的變數都帶有`@Published`特性。\n     2. 在View中初始化該class的實體不需要標記為`@StateObject`。\n     3. 該class也不需要在定義時標記遵守 `ObservableObject`。","n":0.079}}},{"i":52,"$":{"0":{"v":"Environment","n":1},"1":{"v":"\n## Why use it?\n\n有時候我們會需要取得一些裝置、系統設定的資訊如：\n\n- colorScheme 當前系統 深 / 淺 色\n- managedObjectContext CoreData的viewContext\n\n透過`@Environment`我們可以很輕鬆取得這些資訊\n\n## What is it?\n\n他是一個可以用來取得一些SwiftUI預設宣告好的物件。\n\n## Difference between `@EnvironmentObject`\n\n- `@EnvironmentObject` allows us to inject arbitrary values into the environment.\n\n- `@Environment` is specifically there to work with SwiftUI’s own pre-defined keys.\n\n## Behind the scenes","n":0.154}}},{"i":53,"$":{"0":{"v":"Extension","n":1},"1":{"v":"\n## What can we do with Extension?\n\nAdd functionality for class, struct, enum.\n\n- 透過extension，我們可以擴展非open source的程式碼。\n-","n":0.267}}},{"i":54,"$":{"0":{"v":"UIImage","n":1},"1":{"v":"\n```swift\nfunc resize(size: CGSize) -> UIImage? {\n  UIGraphicsBeginImageContext(size)\n  draw(in: CGRect(x: 0, y: 0, width: size.width, height: size.height))\n  let image = UIGraphicGetImageFromCurrentImageContext()\n  UIGraphicsEndImageContext()\n  return image\n}\n```","n":0.209}}},{"i":55,"$":{"0":{"v":"Data Structure","n":0.707},"1":{"v":"\n\n## What does conforming to **Codable** do?\n\n```swift\nstruct Landmark: Codable {\n    var name: String\n    var foundingYear: Int\n\n    // Landmark now supports the Codable methods init(from:) and encode(to:),\n    // even though they aren't written as part of its declaration.\n}\n```\n\n遵循Codable協議就可以在編碼或解碼資料時，將資料轉成swift的資料格式\n\n## 搭配 **CodingKeys** 做 encode, decode\n\n如果api回傳的資料(encoded的格式)跟我們的struct定義不一致，我們可以提供自定義的encode, decode邏輯。\n\n## JSONSerialization\n\n> An object that converts between JSON and the equivalent Foundation objects.\n\n## `Decodable` vs `Decoder` Protocol\n\n`Decodable`是一個Protocol，並要求遵守的類必須提供一個`init()`，而這個`init`函式的唯一input是一個`Decoder`類\n\n```swift\n/// A type that can decode itself from an external representation.\npublic protocol Decodable {\n\n    /// Creates a new instance by decoding from the given decoder.\n    ///\n    /// This initializer throws an error if reading from the decoder fails, or\n    /// if the data read is corrupted or otherwise invalid.\n    ///\n    /// - Parameter decoder: The decoder to read data from.\n    init(from decoder: Decoder) throws\n}\n```\n\n`Decoder`也是一個Protocol，我們使用遵守他的類來解碼payload。\n\n範例：\n\n當我們自定義Decoder的初始化函式時，我們透過`Decoder`實體的`container()` func拿到一個`KeyedDecodingContainer`的實體，並利用這個`container`的`decode()`來解碼payload。\n\nＱ： CodingKeys 扮演什麼角色？\n\nＡ： Decoder呼叫container時需要傳入CodingKeys這個類，之後就可以透過container的`decode`去取值。\n\n```swift\nstruct Person: Decodable {\n    let name: String\n    let age: Int\n    let gender: String\n\n    enum CodingKeys: CodingKey {\n        case name\n        case age\n        case gender\n    }\n\n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        self.name = try container.decode(String.self, forKey: .name)\n        self.age = try container.decode(Int.self, forKey: .age)\n        self.gender = try container.decode(Gender.self, forKey: .gender).rawValue\n    }\n}\n\nenum Gender: String, Decodable {\n    case male\n    case female\n}\n```","n":0.073}}},{"i":56,"$":{"0":{"v":"Serialization","n":1},"1":{"v":"\n**Foundation** library定義了`Encodable`, `Decodable`, 也提供`Encoder`, `Decoder` API讓我們可以很方便地進行資料處理。\n\n當我們需要更深入的設定時，也可以使用`EncodableWithConfiguration`, `DecodableWithConfiguration`這兩個protocols。\n\n## 為何我們需要將資料encode、decode呢？\n\n當我們透過網路傳送資料、將資料存到硬碟上，通常都需要先將檔案編碼成特定的格式再做傳輸、儲存。\n\n而我們在撰寫程式碼時，會定義出一些類(class、struct)，當我們需要將這些類別的實體拿來做傳輸、儲存時，我們必須要讓這個類`Codable`，才可以透過Decoder、Encoder處理我們的資料。\n\n## `Codable` Behind the scenes\n\n![codable behind the scenes](/../assets/images/programming.language.swift.Serialization_behind-the-scenes.png)\n\n## Example\n\n```swift\nstruct TestEncode {\n    let id: String\n    let intArr: [Int] = [1,2,3,4,5]\n}\n\n// Instance method 'encode' requires that 'TestEncode' conform to 'Encodable'\nlet encodedJSONData = try? JSONEncoder().encode(TestEncode(id: \"encode&decode\"))\nlet encodedPropertyListData = try? PropertyListEncoder().encode(TestEncode(id: \"encode&Decode\"))\n```\n\n如果自定義的類沒有遵守`Encodable` protocol，encoder的encode方法是沒有辦法接收自定義類的實例的。\n\n這時候只需要讓TestEncode遵守`Encodable`，即可順利encode了\n\n```swift\nstruct TestEncode: Encodable {\n    let id: String\n    let intArr: [Int] = [1,2,3,4,5]\n}\n```\n\n## Foundation codable types\n\n- String\n- Int\n- Double\n- Date\n- Data\n- URL\n\n## 自定義 `CodingKeys`\n\n當自定義的類遵守`Codable`時，我們可以選擇在類別內宣告一個叫`CodingKeys`的enum，且這個enum需遵守`CodingKey`協議。\n\n```swift\n/// A type that can be used as a key for encoding and decoding.\npublic protocol CodingKey : CustomDebugStringConvertible, CustomStringConvertible, Sendable {\n\n    /// The string to use in a named collection (e.g. a string-keyed dictionary).\n    var stringValue: String { get }\n\n    init?(stringValue: String)\n\n    /// The value to use in an integer-indexed collection (e.g. an int-keyed dictionary).\n    var intValue: Int? { get }\n\n    init?(intValue: Int)\n}\n\nextension CodingKey {\n    /// A textual representation of this key.\n    public var description: String { get }\n\n    /// A textual representation of this key, suitable for debugging.\n    public var debugDescription: String { get }\n}\n```\n\n### Why?\n\n有時候序列化後的資料格式(key-value pair)的key命名並不符合Swift的命名邏輯，且有時候這個key會頻繁被更改，與其隨著這些外部的資料key去做property的命名，不如就透過宣告`CodingKeys`拿來map這些外部的資料格式。\n\n```swift\nlet mockJSONData = \"\"\"\n    {\n      5\"first_name\": \"Jason\",\n      \"last_name\": \"Chung\"\n    }\n\"\"\"\n\nstruct User: Codable {\n    let firstName: String\n    let lastName: String\n\n    enum CodingKeys: String, CodingKey {\n      case firstName = \"first_name\"\n      case lastName = \"last_name\"\n    }\n}\n\nlet encodedJSONData = try! mockJSONData.data(using: .utf8)!\nlet decodedJSONData = try JSONDecoder().decode(User.self, from: encodedJSONData)\n```\n\n## `Codable`常用的情境：\n\n1. JSON Serialization/Deserialization\n2. PropertyList Serialization\n3. UserDefaults\n4. Unit Testing (透過自定義類建立假資料，轉換成JSON格式測試Decoding出錯情境)","n":0.068}}},{"i":57,"$":{"0":{"v":"Decoding JSON","n":0.707}}},{"i":58,"$":{"0":{"v":"Nested Data","n":0.707},"1":{"v":"\n## 前情提要\n\n今天的需求是，前端的資料流以及畫面渲然只需要部分的資料，但是後端訂出的API格式多給了很多暫時不需要的資料。\n\n## 資料處理步驟\n\n### Step1 先釐清前端所需要的資料結構\n\n於是我們考量了`GroceryStore`跟`Product`之間的關聯性，我們定義出了下方的類:\n\n```swift\n// 每間商店包含 商店名、商品陣列\nstruct GroceryStore {\n    var name: String\n    var products: [Product]\n\n    struct Product: Codable {\n        var name: String\n        var points: Int\n        var description: String?\n    }\n}\n```\n\n### Step2 建立一個中繼的類去Decode我們拿回來的資料\n\n但是今天API定出來的資料格式如下：\n\n```json\n[\n    {\n        \"name\": \"Home Town Market\",\n        \"aisles\": [\n            {\n                \"name\": \"Produce\",\n                \"shelves\": [\n                    {\n                        \"name\": \"Discount Produce\",\n                        \"product\": {\n                            \"name\": \"Banana\",\n                            \"points\": 200,\n                            \"description\": \"A banana that's perfectly ripe.\"\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n    {\n        \"name\": \"Big City Market\",\n        \"aisles\": [\n            {\n                \"name\": \"Sale Aisle\",\n                \"shelves\": [\n                    {\n                        \"name\": \"Seasonal Sale\",\n                        \"product\": {\n                            \"name\": \"Chestnuts\",\n                            \"points\": 700,\n                            \"description\": \"Chestnuts that were roasted over an open fire.\"\n                        }\n                    },\n                    {\n                        \"name\": \"Last Season's Clearance\",\n                        \"product\": {\n                            \"name\": \"Pumpkin Seeds\",\n                            \"points\": 400,\n                            \"description\": \"Seeds harvested from a pumpkin.\"\n                        }\n                    }\n                ]\n            }\n        ]\n    }\n]\n```\n\n於是我們建立了一個中繼的類，去接收傳過來的資料。\n\n```swift\nstruct GroceryStoreService {\n    let name: String\n    let aisles: [Aisles]\n\n    struct Aisles: Decodable {\n        let name: String\n        let shelves: [Shelves]\n\n        struct Shelves: Decodable {\n            let name: String\n            let product: GroceryStore.Product\n        }\n    }\n}\n```\n\n### Step3 把Step1建立的類透過`extension`讓我們可以透過中繼類初始化我們真正需要的資料\n\n```swift\nextension GroceryStore {\n    init(from service: GroceryDataService) {\n        name = service.name\n\n        products = []\n        for aisle in service.aisles {\n            for shelf in service.shelves {\n                product.append(shelf.product)\n            }\n        }\n    }\n}\n```","n":0.074}}},{"i":59,"$":{"0":{"v":"Merge Data","n":0.707},"1":{"v":"\n## 前情提要\n\n很多時候前端定義出的model跟資料來源有點出入，例如：\n\n我們定義的Model:\n\n```swift\nstruct Team: Codable {\n    var members: [Member]\n    let id: String\n\n    struct Member: Codable {\n      let name: String\n      let id: String\n      let age: Int\n    }\n}\n```\n\n預期進來的資料是 ⇩\n\n```json\n{\n    \"members\": [\n        {\n            \"name\": \"Jason\",\n            \"id\": \"123\",\n            \"age\": 20\n        },\n        {\n            \"name\": \"Lyy\",\n            \"id\": \"456\",\n            \"age\": 18\n        }\n    ]\n}\n```\n\n但是實際資料是 ⇩，這時候我們就會需要針對key去做特別的處理。\n\n```json\n// 實際的 JSON Data\n{\n    \"members\": [\n        \"Jason\": {\n            \"id\": \"123\",\n            \"age\": 20\n        },\n        \"Lyy\": {\n            \"id\": \"456\",\n            \"age\": 18\n        }\n    ]\n}\n```\n\n這個時候我們不應該為了Decode而再建立一個新的類別，專門去迎合資料的結構，而是加工處理進來的資料，讓他符合我們App開發的商業邏輯。\n\n## 資料處理步驟\n\n```swift\nextension Team {\n    struct MemberKey: CodingKey {\n        var stringValue: String\n\n        init?(stringValue: String) {\n          self.stringValue = stringValue\n        }\n\n        var intValue: Int?\n\n        init?(intValue: Int) {\n          return nil\n        }\n\n        static let id = MemberKey(stringValue: \"id\")!\n        static let age = MemberKey(stringValue: \"age\")!\n    }\n\n    enum CodingKeys: CodingKey {\n        case members\n        case id\n    }\n\n    func encode(to encoder: Encoder) throws {\n        var container = encoder.container(keyedBy: CodingKeys.self)\n\n        try container.encode(id, forKey: .id)\n        var memberContainer = container.nestedContainer(keyedBy: MemberKey.self, forKey: .members)\n\n        for member in members {\n            let nameKey = MemberKey(stringValue: member.name)!\n\n            var nestedContainer = memberContainer.nestedContainer(keyedBy: MemberKey.self, forKey: nameKey)\n            try nestedContainer.encode(member.id, forKey: .id)\n            try nestedContainer.encode(member.age, forKey: .age)\n        }\n    }\n\n    init(from decoder: Decoder) throws {\n        let container = try decoder.container(keyedBy: CodingKeys.self)\n        let memberContainer = try container.nestedContainer(keyedBy: MemberKey.self, forKey: .members)\n        id = try container.decode(String.self, forKey: .id)\n\n        members = []\n        for key in memberContainer.allKeys {\n            let memberContainer = try memberContainer.nestedContainer(keyedBy: MemberKey.self, forKey: key)\n            let age = try memberContainer.decode(Int.self, forKey: .age)\n            let id = try memberContainer.decode(String.self, forKey: .id)\n\n            members.append(Member(name: key.stringValue, id: id, age: age))\n      }\n    }\n}\n```","n":0.067}}},{"i":60,"$":{"0":{"v":"Git Flow","n":0.707},"1":{"v":"\n```mermaid\n    gitGraph\n       commit id: \"init\"\n       branch release\n       branch develop\n       branch be_feature1\n       branch be_feature2\n       branch fe_feature1\n       branch fe_feature2\n       checkout be_feature1\n       commit\n       commit\n       commit\n       checkout be_feature2\n       commit\n       commit\n       commit\n       checkout fe_feature1\n       commit\n       commit\n       checkout fe_feature2\n       commit\n       commit\n       checkout develop\n       merge be_feature1\n       merge be_feature2\n       merge fe_feature1\n       merge fe_feature2\n       checkout release\n       merge develop\n       checkout main\n       merge release\n```\n\n```git\n[type] title\nbody\nfooter\n```","n":0.136}}},{"i":61,"$":{"0":{"v":"Design Pattern","n":0.707}}},{"i":62,"$":{"0":{"v":"POP","n":1},"1":{"v":"\n## What POP differs from OOP\n\n- Classes can only inherit from one other class while protocols can inherit from multiple protocols.\n- Large hierarchies can easily pollute subclasses with too many extra features.\n\n## POP + Value Semantic = Performance & Local Reasoning","n":0.156}}},{"i":63,"$":{"0":{"v":"OOP","n":1},"1":{"v":"\n## Languages\n\n- Python\n- C#\n- Java\n- Ruby\n\n## Pillars\n\n```mermaid\nflowchart TD\n  A[OOP Pillars] --> B[Inheritance]\n  A --> C[Polymorphism]\n  A --> D[Encapsulation]\n  A --> E[Abstraction]\n```\n\n1. Inheritance:\n   1. code reusability\n2. Polymorphism\n   1. overriding methods in child classes\n3. Encapsulation\n   1. hide private interface, show with public\n   2. access control\n4. Abstraction\n\n## Building blocks\n\n- Classes\n- Objects\n- Methods\n- Attributes","n":0.141}}},{"i":64,"$":{"0":{"v":"Network","n":1}}},{"i":65,"$":{"0":{"v":"webRTC","n":1},"1":{"v":"\n## 實現WebRTC的步驟\n\n1. Signalling\n\n開啟直播的Peer需要提供一個offer，裡面包含SDP(session description protocol)，會寫在signal server，才能讓另一位的peer回應這個SDP。\n\n需要交換的資訊：\n- IP Address\n- audio + video tracks\n- data channels that determine the media type with a resolution exchange\n\n2. Connecting\n\nPeer彼此之間需要產生一個list的ICE(IP/port pair)，才能讓WebRTC透過STUN Server連接。\n每個Peer一樣要將他們的ICE寫入firestore，才能讓其他peer讀到。\n\n- ICE: Interactive connectivity establishment (uses STUN/TURN servers)\n  - **STUN** Standard Traversal Utilities for NAT\n    - 幫忙取得網路IP -> 透過發送Stun server請求\n  - **TURN** Traversal Using Relays around NAT\n    - 幫忙處理裝置之間因為防火牆而中斷連線的server\n    - These servers are used to work up with the privacy of the agents by not letting the servers locate the IP of the communicators. TURN creates a temporary IP for the agents to generate traffic to and fro, acting as a proxy.\n\n3. Securing\n\n- DTLS(Datagram Transport Layer Security)\n  - allows webRTC to establish a secured and encrypted communication between two peers. The client and the server to communicate, need a agree on certain values known as ciphers in a DTLS handshake. To secure the data streams of the peers, DTLS is required\n- SRTP(Secure Real-time Transport Protocol)\n  - It secures and encrypts the media streams between two connecting peers. It is initialized by using keys generated by DTLS. This protocol is specifically designed for encrypting RTP packets.","n":0.075}}},{"i":66,"$":{"0":{"v":"Web Socket","n":0.707},"1":{"v":"\n## What is Socket.IO\n\n一個函式庫，用途在於實現Server跟Client的溝通\n\n- 一個整合node.js http Server的套件 (socket.io)\n- 封裝客戶端http\n\n## Why Socket.IO?\n\n1. 低延遲\n2. 雙向\n3. event base\n\n## How to use Socket.IO?\n\n- Server:\n  1. 引入套件封裝好的 **Server** class\n  2. 將node:http建立出來的**HTTP server**物件當參數來初始化 socket 的 **Server** class\n\n      ```js\n      import express from 'express';\n      import { createServer} from 'node:http';\n      import { Server } from 'socket.io';\n\n      const app = express();\n      const server = createServer(app);\n      const io = new Server(server)\n      ```\n\n  3. 透過這樣子產生出來的io實體，可以透過`on` method開啟socket通道\n\n      ```js\n      io.emit('hello','world') // 提交給所有connected的sockets\n\n      io.on('connection', (socket) => {\n        socket.broadcast.emit('hi');\n      })\n      ```\n\n  4. 後端透過emit傳送訊息給前端\n\n- Client:\n  1. 前端會需要一個io實例\n  2. 透過io實例的emit提交客戶端訊息\n\n## Remember\n\n1. 前端的socket不會永遠都連線中\n2. server端的socket不會存任何事件\n","n":0.108}}},{"i":67,"$":{"0":{"v":"Job Findin","n":0.707}}},{"i":68,"$":{"0":{"v":"Resume","n":1},"1":{"v":"\n## **Summary**\n\nI transitioned from a financial background to the realm of Front-End development. I believe my passion for technology will remain fervent and ever-growing.\n\n## **Technical Skills**\n\n- Languages: Swift, JavaScript\n- Design Patterns: MVC, MVVM\n- App Develop Frameworks: SwiftUI, UIKit, Combine\n- Reactive Frameworks: Combine\n- CI / CD: Xcode Cloud\n\n## **Work Experiences**\n\n### AppWorks School, iOS Development, Sep 2023 - Jan 2023\n\n- Successfully developed the \"Flavor Flash\" personal project within 5-week, showcasing proficiency in SwiftUI—an initial foray into this framework.\n- Successfully implemented the \"STYLiSH\" E-Commerce project using UIKit, meeting the specifications outlined in Figma.\n- Collaborated seamlessly with web front-end and back-end developers to integrate new features into the \"STYLiSH\" project, earning a commendable 2nd place.\n- Enrolled in AppWorks School, securing admission with a acceptance rate of less than 10%.\n\n### Front-End Engineer, Wisdom Courage, May 2023 - Aug 2023\n\n- Enhance existing projects by incorporating new features as per the product manager's requirements.\n- Resolve bug tickets on Redmine, demonstrating proficiency in issue resolution and ensuring project quality.\n- Developed Content Management System front-end interfaces based on product managers requirements, collaborating with back-end engineers to seamlessly integrate API endpoints.\n\n### Auditor, Deloitte, Oct 2021 - Sep 2022\n\n- Collaborated with a team of auditors to review and analysis of Cathay United Bank's financial statements for Q3 and Q4 2021, as well as Q1 and Q2 2022.\n- Complete worksheets assigned by supervisors and proactive follow-up with clients to obtain financial information.\n\n## **Education**\n\n### National Sun Yat-Sen University\n\n#### Bachelor's degree in Finance\n\n- Served as department representative for one year.\n- Served as sport teaching assistant for two years.\n- Served as Power Dance Club breaking instructioal leader for one year.\n- Participated in the organization and coordination of large scale street dance competition.\n\n## **Projects**\n\nFlavor Flash\n\n> An culinary explorer hub for foodies, so they can share their meal by photo or live stream.\n\n- Developed with SwiftUI, implementing the MVVM architecture coupled with Combine for enhanced flexibility and maintainability.\n- Design adaptable custom UI components, incorporating a comprehensive style guide through viewModifiers to ensure a unified and flexible app interface.\n- Designed a camera class, utilizing AVFoundation's API to proficiently manipulate the user's device camera.\n- Implemented live streaming functionality using WebRTC, with Cloud Firestore serving as the signaling client for seamless communication.\n- Food analysis through CoreML + Vision, using a self-trained model created with CreateML for enhanced accuracy and customization.\n- Implemented chat functionality by actively listening to a Cloud Firestore collection for real-time communication.\n- Utilized Cloud Firestore as the database infrastructure with self-designed data structure.\n","n":0.05}}},{"i":69,"$":{"0":{"v":"Leet Code","n":0.707},"1":{"v":"\n## 21. Merge two LinkedList\n\n2023/12/23 解題思路： 先將兩個LinkedList都轉成`Array`，然後將他們的值加總並排序(`sorted()`)，最後在用這個處理後的`Array`去將每個element map 成 `ListNode`，跑迴圈將每個`ListNode`串接起來\n\n```swift\nclass Solution {\n    func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {\n        func getLinkedArr(_ list: ListNode?) -> [Int] {\n            guard let list else { return [] }\n            var returnArr: [Int] = []\n\n            if let nextNode = list.next {\n                returnArr += [list.val]\n                return returnArr + getLinkedArr(nextNode)\n            } else {\n                return returnArr + [list.val]\n            }\n        }\n\n        func generateListNode(from array: [Int]) -> ListNode? {\n            if array.isEmpty {\n                return nil\n            }\n\n            var listNodeArr = array.map { ListNode($0) }\n\n            for (index, node) in listNodeArr.enumerated() {\n                if index == (listNodeArr.count - 1) {\n                    break\n                }\n                node.next = listNodeArr[index + 1]\n            }\n\n            return listNodeArr[0]\n        }\n\n        var list1Arr = getLinkedArr(list1)\n        var list2Arr = getLinkedArr(list2)\n        var sumListArr = (list1Arr + list2Arr).sorted()\n\n        return generateListNode(from: sumListArr)\n    }\n}\n```\n\n反思：\n應該應用遞迴的特性，讓listNode去比較並尋找應該接在下一個的listNode，不斷地重複直到沒有下一個listNode.\n\n## 26. Remove Duplicates from Sorted Array\n\n2023/12/24 解題思路：\n\n先宣告一個空的陣列，然後將參數的nums陣列跑迴圈，如果nums陣列中的element沒有包含在substituteNums陣列中，就加進去，否則跳過。\n\n最後再將 substituteNums賦值給nums，並回傳substituteNums的陣列長度。\n\n```swift\nclass Solution {\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\n        var substituteNums: [Int] = []\n\n        for (index, num) in nums.enumerated() {\n            if substituteNums.contains(num) {\n\n            } else {\n                substituteNums.append(num)\n            }\n        }\n        nums = substituteNums\n        return substituteNums.count\n    }\n}\n```\n\n反思：\n\n```swift\nclass Solution {\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\n        var idx = 0\n        for num in nums where num != nums[idx] {\n            // 第一個num一定不會被跑到\n            idx += 1\n            nums[idx] = num\n        }\n\n        return idx + 1\n    }\n}\n```","n":0.07}}}]}
